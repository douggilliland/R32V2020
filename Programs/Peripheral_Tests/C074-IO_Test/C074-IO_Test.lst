;
; C074-IO_Test - Read a line from the UART serial input
; Echo line to the serial port and to the screen
; Parse the line
;

prompt:			.string "R32V2020> "
; lineBuff is 80 characters long
lineBuff:		.string "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
syntaxError:	.string "Syntax error"
runningString:	.string "Running..."
hitAnyKey:		.string "Hit any key to exit..."
menuItem_01:	.string "01-Ring LED Test      "
menuItem_02:	.string "02-7 Segment LED Test "
menuItem_03:	.string "03-Pushbutton Test    "
menuItem_04:	.string "04-DIP Switch Test    "
menuItem_05:	.string "05-ANSI Screen Test   "
menuItem_06:	.string "06-Serial Port Test   "
menuItem_07:	.string "07-MCP23008 I2C Test  "
menuItem_08:	.string "08-MCP4231 SPI Test   "
menuItem_09:	.string "09-PS/2 Keyboard Test "
menuItem_10:	.string "10-Buzzer Test        "
menuItem_11:	.string "11-Timers Test        "
menuItem_12:	.string "12-TBD Test           "

;
; Read a line from the UART and parse the line
;

main:
00000000	D400035F	bsr		clearScreen_ANSI_UART
00000001	D4000004	bsr		printMenu
00000002	D40001AA	bsr		readToLineBuffer
00000003	D400001E	bsr		parseLine
00000004	C0FFFFFC	bra		main

;
; printMenu - Print the menu
;

printMenu:
00000005	A0408000	push	r8
00000006	D4000352	bsr		newLine_ANSI_UART
00000007	42800094	lix		r8,menuItem_01.lower
00000008	D4000339	bsr		printString_ANSI_UART
00000009	428000AC	lix		r8,menuItem_02.lower
0000000a	D4000337	bsr		printString_ANSI_UART
0000000b	428000C4	lix		r8,menuItem_03.lower
0000000c	D4000340	bsr		printLinebuffer_ANSI_UART
0000000d	428000DC	lix		r8,menuItem_04.lower
0000000e	D4000333	bsr		printString_ANSI_UART
0000000f	428000F4	lix		r8,menuItem_05.lower
00000010	D4000331	bsr		printString_ANSI_UART
00000011	4280010C	lix		r8,menuItem_06.lower
00000012	D400033A	bsr		printLinebuffer_ANSI_UART
00000013	42800124	lix		r8,menuItem_07.lower
00000014	D400032D	bsr		printString_ANSI_UART
00000015	4280013C	lix		r8,menuItem_08.lower
00000016	D400032B	bsr		printString_ANSI_UART
00000017	42800154	lix		r8,menuItem_09.lower
00000018	D4000334	bsr		printLinebuffer_ANSI_UART
00000019	4280016C	lix		r8,menuItem_10.lower
0000001a	D4000327	bsr		printString_ANSI_UART
0000001b	42800184	lix		r8,menuItem_11.lower
0000001c	D4000330	bsr		printLinebuffer_ANSI_UART
0000001d	42800000	lix		r8,prompt.lower
0000001e	D4000323	bsr		printString_ANSI_UART
0000001f	A1804000	pull	r8
00000020	A1704000	pull	PC

;
; parseLine -
; line is in lineBuff
;

parseLine:
00000021	A0408000	push	r8
00000022	4280000C	lix		r8,lineBuff.lower
00000023	D40001D7	bsr		hexToSevenSeg
; Check to see if the command is 0x01
00000024	39380001	cmpi	r8,0x01
00000025	D2000003	bne		skipTo2
00000026	D4000032	bsr		testRingLEDs
00000027	C000002D	bra		doneTests
; Check to see if the command is 0x02
skipTo2:
00000028	39380002	cmpi	r8,0x02
00000029	D2000003	bne		skipTo3
0000002a	D4000045	bsr		test7Segs
0000002b	C0000029	bra		doneTests
; Check to see if the command is 0x03
skipTo3:
0000002c	39380003	cmpi	r8,0x03
0000002d	D2000003	bne		skipTo4
0000002e	D4000059	bsr		testPushbuttons
0000002f	C0000025	bra		doneTests
; Check to see if the command is 0x04
skipTo4:
00000030	39380004	cmpi	r8,0x04
00000031	D2000003	bne		skipTo5
00000032	D400006F	bsr		testDIPSwitches
00000033	C0000021	bra		doneTests
; Check to see if the command is 0x05
skipTo5:
00000034	39380005	cmpi	r8,0x05
00000035	D2000003	bne		skipTo6
00000036	D4000089	bsr		testANSIScreen
00000037	C000001D	bra		doneTests
; Check to see if the command is 0x06
skipTo6:
00000038	39380006	cmpi	r8,0x06
00000039	D2000003	bne		skipTo7
0000003a	D40000E5	bsr		testSerialPort
0000003b	C0000019	bra		doneTests
; Check to see if the command is 0x07
skipTo7:
0000003c	39380007	cmpi	r8,0x07
0000003d	D2000003	bne		skipTo8
0000003e	D40000ED	bsr		testMCP23008
0000003f	C0000015	bra		doneTests
; Check to see if the command is 0x08
skipTo8:
00000040	39380008	cmpi	r8,0x08
00000041	D2000003	bne		skipTo9
00000042	D4000104	bsr		testMCP4231
00000043	C0000011	bra		doneTests
; Check to see if the command is 0x09
skipTo9:
00000044	39380009	cmpi	r8,0x09
00000045	D2000003	bne		skipTo10
00000046	D4000111	bsr		testPS2Keyboard
00000047	C000000D	bra		doneTests
; Check to see if the command is 0x10
skipTo10:
00000048	39380010	cmpi	r8,0x10
00000049	D2000003	bne		skipTo11
0000004a	D4000118	bsr		testBuzzer
0000004b	C0000009	bra		doneTests
;
skipTo11:
0000004c	39380011	cmpi	r8,0x11
0000004d	D2000003	bne		skipTo12
0000004e	D400011F	bsr		testTBD
0000004f	C0000005	bra		doneTests

skipTo12:
00000050	A0408000	push	r8
00000051	42800060	lix		r8,syntaxError.lower
00000052	D40002EF	bsr		printString_ANSI_UART
00000053	A1804000	pull	r8
doneTests:
00000054	428007D0	lix		r8,2000
00000055	D400027D	bsr		delay_mS
00000056	A1804000	pull	r8
00000057	A1704000	pull	PC

;
; Test Ring LEDs
;

testRingLEDs:
00000058	A0408000	push	r8
00000059	42800070	lix		r8,runningString.lower
0000005a	D40002E7	bsr		printString_ANSI_UART
0000005b	42800094	lix		r8,menuItem_01.lower
0000005c	D40002F0	bsr		printLinebuffer_ANSI_UART
0000005d	4280007C	lix		r8,hitAnyKey.lower
0000005e	D40002E3	bsr		printString_ANSI_UART
reload:
0000005f	42800001	lix		r8,1
loopLEDRing:
00000060	D4000145	bsr		putValueToRingLEDs	; put the switches to the 7 Segment LED
00000061	A0408000	push	r8
00000062	428000FA	lix		r8,250				; wait for 1 second
00000063	D400026F	bsr		delay_mS
00000064	A1804000	pull	r8
00000065	30808000	sl1		r8,r8
00000066	39380801	cmpi	r8,0x0801
00000067	D2FFFFF9	bne		loopLEDRing
00000068	42800000	lix		r8,0
00000069	D400013C	bsr		putValueToRingLEDs	; put the switches to the 7 Segment LED
0000006a	D4000254	bsr		checkForCharAndDiscard
0000006b	39380000	cmpi	r8,0
0000006c	D1FFFFF3	beq		reload
0000006d	A1804000	pull	r8
0000006e	A1704000	pull	PC

;
; Seven Segment Display Test
;

test7Segs:
0000006f	A0408000	push	r8
00000070	42800070	lix		r8,runningString.lower
00000071	D40002D0	bsr		printString_ANSI_UART
00000072	428000AC	lix		r8,menuItem_02.lower
00000073	D40002D9	bsr		printLinebuffer_ANSI_UART
00000074	4280007C	lix		r8,hitAnyKey.lower
00000075	D40002CC	bsr		printString_ANSI_UART
rerun7Segs:
00000076	41801234	liu		r8,0x1234
00000077	40805678	lil		r8,0x5678
00000078	D400017B	bsr		wr7Seg8Dig
00000079	428007D0	lix		r8,2000
0000007a	D4000258	bsr		delay_mS
0000007b	4180ABCD	liu		r8,0xABCD
0000007c	4080EF12	lil		r8,0xEF12
0000007d	D4000176	bsr		wr7Seg8Dig
0000007e	428007D0	lix		r8,2000
0000007f	D4000253	bsr		delay_mS
00000080	42800000	lix		r8,0x0
00000081	D4000172	bsr		wr7Seg8Dig
00000082	D400023C	bsr		checkForCharAndDiscard
00000083	39380000	cmpi	r8,0
00000084	D1FFFFF2	beq		rerun7Segs
00000085	A1804000	pull	r8
00000086	A1704000	pull	PC


; wr7Seg8Dig
; passed r8 - value to send to the 7 seg display

; wr7Seg8Dig:
; push	PAR
; push	r8
; lix		PAR,0x3000		; Seven Segment LED lines
; spl		r8				; Write out LED bits
; pull	r8
; pull	PAR
; pull	PC

;
; Pushbutton Test
; r8 used for temporary variables
; r9 stores the previous button value
;

testPushbuttons:
00000087	A0408000	push	r8
00000088	A0409000	push	r9
00000089	42800070	lix		r8,runningString.lower
0000008a	D40002B7	bsr		printString_ANSI_UART
0000008b	428000C4	lix		r8,menuItem_03.lower
0000008c	D40002C0	bsr		printLinebuffer_ANSI_UART
0000008d	4280007C	lix		r8,hitAnyKey.lower
0000008e	D40002BE	bsr		printLinebuffer_ANSI_UART
0000008f	42900000	lix		r9,0x0
loopSwRead:
00000090	D400022E	bsr		checkForCharAndDiscard
00000091	39380001	cmpi	r8,1
00000092	D100000C	beq		doneWithSwitches
00000093	D400017F	bsr		readSws		; returns switches and pushbuttons in r8
00000094	2B880007	andi	r8,r8,0x7	; just the pushbuttons
00000095	21880030	addi	r8,r8,0x30
00000096	38389000	cmp		r8,r9
00000097	D1FFFFF9	beq		loopSwRead
00000098	21980000	addi	r9,r8,0
00000099	D4000319	bsr		printByte_ANSI_UART
0000009a	D40002BE	bsr		newLine_ANSI_UART
0000009b	428000FA	lix		r8,250
0000009c	D4000236	bsr		delay_mS
0000009d	C0FFFFF3	bra		loopSwRead
doneWithSwitches:
0000009e	A1904000	pull	r9
0000009f	A1804000	pull	r8
000000a0	A1704000	pull	PC

;
; DIP Switch Test
;

testDIPSwitches:
000000a1	A0408000	push	r8
000000a2	A0409000	push	r9
000000a3	42800070	lix		r8,runningString.lower
000000a4	D400029D	bsr		printString_ANSI_UART
000000a5	428000DC	lix		r8,menuItem_04.lower
000000a6	D40002A6	bsr		printLinebuffer_ANSI_UART
000000a7	4280007C	lix		r8,hitAnyKey.lower
000000a8	D40002A4	bsr		printLinebuffer_ANSI_UART
000000a9	42900000	lix		r9,0x0
000000aa	42800000	lix		r8,0x0
000000ab	D4000148	bsr		wr7Seg8Dig
loopSwRead2:
000000ac	D4000212	bsr		checkForCharAndDiscard
000000ad	39380001	cmpi	r8,1
000000ae	D100000E	beq		doneWithDIPSwitches
000000af	D4000163	bsr		readSws		; returns switches and pushbuttons in r8
000000b0	32808000	sr1		r8,r8
000000b1	32808000	sr1		r8,r8
000000b2	32808000	sr1		r8,r8
000000b3	32808000	sr1		r8,r8
000000b4	2B8800FF	andi	r8,r8,0xff
000000b5	38389000	cmp		r8,r9
000000b6	D1FFFFF6	beq		loopSwRead2
000000b7	21980000	addi	r9,r8,0
000000b8	D400013B	bsr		wr7Seg8Dig
000000b9	428000FA	lix		r8,250
000000ba	D4000218	bsr		delay_mS
000000bb	C0FFFFF1	bra		loopSwRead2
doneWithDIPSwitches:
000000bc	A1904000	pull	r9
000000bd	A1804000	pull	r8
000000be	A1704000	pull	PC

;
; ANSI Screen Test
;

redString:		.string "Red "
greenString:	.string "Green "
blueString:		.string "Blue "
cyanString:		.string "Cyan "
magentaString:	.string "Magenta "
yellowString:	.string "Yellow "
blackString:	.string "Black "
grayString:		.string "Gray "
onString:		.string "on "
brightString:	.string "Bright "

testANSIScreen:
000000bf	A0408000	push	r8
000000c0	42800070	lix		r8,runningString.lower
000000c1	D4000280	bsr		printString_ANSI_UART
000000c2	428000F4	lix		r8,menuItem_05.lower
000000c3	D4000289	bsr		printLinebuffer_ANSI_UART
000000c4	42800020	lix		r8,0x20			; start with a space
anotherCharT5:
000000c5	D4000242	bsr		putChar_ANSI
000000c6	21880001	addi	r8,r8,1
000000c7	393800FF	cmpi	r8,0xFF
000000c8	D2FFFFFD	bne		anotherCharT5
000000c9	D4000249	bsr		newLine_ANSI
; Test screen character colors
; Light characters
defaultColors:	.string "[0;1m"
000000ca	42800204	lix		r8,defaultColors.lower
000000cb	D4000100	bsr		printANSICode
redChars:	.string	"[31;22m"
000000cc	4280020C	lix		r8,redChars.lower
000000cd	D40000FE	bsr		printANSICode
000000ce	428001B4	lix		r8,redString.lower
000000cf	D400024A	bsr		printString_ANSI
grnChars:	.string	"[32m"
000000d0	42800214	lix		r8,grnChars.lower
000000d1	D40000FA	bsr		printANSICode
000000d2	428001BC	lix		r8,greenString.lower
000000d3	D4000246	bsr		printString_ANSI
bluChars:	.string	"[34m"
000000d4	4280021C	lix		r8,bluChars.lower
000000d5	D40000F6	bsr		printANSICode
000000d6	428001C4	lix		r8,blueString.lower
000000d7	D4000242	bsr		printString_ANSI
cyanChars:	.string	"[36m"
000000d8	42800224	lix		r8,cyanChars.lower
000000d9	D40000F2	bsr		printANSICode
000000da	428001CC	lix		r8,cyanString.lower
000000db	D400023E	bsr		printString_ANSI
magChars:	.string	"[35m"
000000dc	4280022C	lix		r8,magChars.lower
000000dd	D40000EE	bsr		printANSICode
000000de	428001D4	lix		r8,magentaString.lower
000000df	D400023A	bsr		printString_ANSI
yelChars:	.string	"[33m"
000000e0	42800234	lix		r8,yelChars.lower
000000e1	D40000EA	bsr		printANSICode
000000e2	428001E0	lix		r8,yellowString.lower
000000e3	D4000236	bsr		printString_ANSI
000000e4	D400022E	bsr		newLine_ANSI
000000e5	42800204	lix		r8,defaultColors.lower
000000e6	D40000E5	bsr		printANSICode
; Bright characters
redChars2:	.string	"[31;1m"
000000e7	4280023C	lix		r8,redChars2.lower
000000e8	D40000E3	bsr		printANSICode
000000e9	428001B4	lix		r8,redString.lower
000000ea	D400022F	bsr		printString_ANSI
000000eb	42800214	lix		r8,grnChars.lower
000000ec	D40000DF	bsr		printANSICode
000000ed	428001BC	lix		r8,greenString.lower
000000ee	D400022B	bsr		printString_ANSI
000000ef	4280021C	lix		r8,bluChars.lower
000000f0	D40000DB	bsr		printANSICode
000000f1	428001C4	lix		r8,blueString.lower
000000f2	D4000227	bsr		printString_ANSI
000000f3	42800224	lix		r8,cyanChars.lower
000000f4	D40000D7	bsr		printANSICode
000000f5	428001CC	lix		r8,cyanString.lower
000000f6	D4000223	bsr		printString_ANSI
000000f7	4280022C	lix		r8,magChars.lower
000000f8	D40000D3	bsr		printANSICode
000000f9	428001D4	lix		r8,magentaString.lower
000000fa	D400021F	bsr		printString_ANSI
000000fb	42800234	lix		r8,yelChars.lower
000000fc	D40000CF	bsr		printANSICode
000000fd	428001E0	lix		r8,yellowString.lower
000000fe	D400021B	bsr		printString_ANSI
000000ff	D4000213	bsr		newLine_ANSI
00000100	42800204	lix		r8,defaultColors.lower
00000101	D40000CA	bsr		printANSICode
; Red on Black
redOnBlackANSI:	.string	"[27;40;31m"
00000102	42800244	lix		r8,redOnBlackANSI.lower
00000103	D40000C8	bsr		printANSICode
00000104	428001B4	lix		r8,redString.lower
00000105	D4000214	bsr		printString_ANSI
00000106	428001F8	lix		r8,onString.lower
00000107	D4000212	bsr		printString_ANSI
00000108	428001F0	lix		r8,grayString.lower
00000109	D4000210	bsr		printString_ANSI
; Bright Yellow on Green
brtYelOnGrn:	.string "[93;42m"
0000010a	42800250	lix		r8,brtYelOnGrn.lower
0000010b	D40000C0	bsr		printANSICode
0000010c	428001FC	lix		r8,brightString.lower
0000010d	D400020C	bsr		printString_ANSI
0000010e	428001E0	lix		r8,yellowString.lower
0000010f	D400020A	bsr		printString_ANSI
00000110	428001F8	lix		r8,onString.lower
00000111	D4000208	bsr		printString_ANSI
00000112	428001BC	lix		r8,greenString.lower
00000113	D4000206	bsr		printString_ANSI
; Reset to default colors
00000114	42800204	lix		r8,defaultColors.lower
00000115	D40000B6	bsr		printANSICode
00000116	D40001FC	bsr		newLine_ANSI
; Hit any key to continue
00000117	D4000241	bsr		newLine_ANSI_UART
00000118	4280007C	lix		r8,hitAnyKey.lower
00000119	D4000233	bsr		printLinebuffer_ANSI_UART
keepCheckCharIn:
0000011a	D40001A4	bsr		checkForCharAndDiscard
0000011b	39380000	cmpi	r8,0
0000011c	D1FFFFFE	beq		keepCheckCharIn
0000011d	A1804000	pull	r8
0000011e	A1704000	pull	PC

;
; Serial Port Test
;

testSerialPort:
0000011f	A0408000	push	r8
00000120	42800070	lix		r8,runningString.lower
00000121	D4000220	bsr		printString_ANSI_UART
00000122	4280010C	lix		r8,menuItem_06.lower
00000123	D4000229	bsr		printLinebuffer_ANSI_UART
00000124	42800020	lix		r8,0x20			; start with a space
anotherCharT6:
00000125	D4000172	bsr		putChar_UART
00000126	21880001	addi	r8,r8,1
00000127	3938007F	cmpi	r8,0x7f
00000128	D2FFFFFD	bne		anotherCharT6
00000129	A1804000	pull	r8
0000012a	A1704000	pull	PC

;
; MCP23008 I2C Test
;

testMCP23008:
0000012b	42800070	lix		r8,runningString.lower
0000012c	D4000215	bsr		printString_ANSI_UART
0000012d	42800124	lix		r8,menuItem_07.lower
0000012e	D400021E	bsr		printLinebuffer_ANSI_UART
0000012f	4280007C	lix		r8,hitAnyKey.lower
00000130	D400021C	bsr		printLinebuffer_ANSI_UART
; Code to initialize I2CIO8 card
00000131	D40000E7	bsr		init_Regs_I2CIO8	; initialize the MCP23008 on the I2CIO8
restartLoop:
00000132	42800008	lix		r8,0x08
loopMain:
00000133	D4000100	bsr		wrI2CAdrDat_MCP23008	; write to LEDs
00000134	D4000008	bsr		delayFromJumpers
00000135	32808000	sr1		r8,r8					; shift LED bit right by 1
00000136	39380000	cmpi	r8,0
00000137	D2FFFFFC	bne		loopMain
00000138	D4000186	bsr		checkForCharAndDiscard
00000139	39380000	cmpi	r8,0
0000013a	D1FFFFF8	beq		restartLoop				; restart the shifting
0000013b	A1704000	pull	PC

;
; delayFromJumpers - Set delay based on header value
; returns: nothing (restores registers at return)
;

delayFromJumpers:
0000013c	A0408000	push	r8
0000013d	D4000104	bsr		readI2CDat_MCP23008		; read headers into r8
0000013e	2C882000	xor		r8,r8,MINUS1			; invert headers
0000013f	2B8800F0	andi	r8,r8,0xF0				; keep 8 bits
00000140	30808000	sl1		r8,r8
00000141	30808000	sl1		r8,r8
00000142	30808000	sl1		r8,r8
00000143	D400018F	bsr		delay_mS
00000144	A1804000	pull	r8
00000145	A1704000	pull	PC

;
; MCP4231 SPI Test
; Write ramp output to SPI-POTX2
; x6000-x67FF (2KB)	- SPI Address Range
; x6000 - d0-d7 = Write value
; x6001 - d0 = Write Chip Select line
; x6002 - d0 = Busy flag
;

testMCP4231:
00000146	A0408000	push	r8
00000147	42800070	lix		r8,runningString.lower
00000148	D40001F9	bsr		printString_ANSI_UART
00000149	4280013C	lix		r8,menuItem_08.lower
0000014a	D4000202	bsr		printLinebuffer_ANSI_UART
0000014b	4280007C	lix		r8,hitAnyKey.lower
0000014c	D4000200	bsr		printLinebuffer_ANSI_UART
reloadr8:
0000014d	42800000	lix		r8,0x00				; sent out low voltage from pot
loopForever:
0000014e	D4000124	bsr		writeSPI0
0000014f	21880001	addi	r8,r8,0x1
00000150	39380080	cmpi	r8,0x80
00000151	D2FFFFFD	bne		loopForever
00000152	D400016C	bsr		checkForCharAndDiscard
00000153	39380000	cmpi	r8,0
00000154	D1FFFFF9	beq		reloadr8
00000155	A1804000	pull	r8
00000156	A1704000	pull	PC

;
; PS/2 Keyboard Test
; 0x0D
;

testPS2Keyboard:
00000157	A0408000	push	r8
00000158	42800070	lix		r8,runningString.lower
00000159	D40001E8	bsr		printString_ANSI_UART
0000015a	42800154	lix		r8,menuItem_09.lower
0000015b	D40001F1	bsr		printLinebuffer_ANSI_UART
loopForeverT9:
0000015c	D4000146	bsr		getPS2Char
0000015d	D4000255	bsr		printByte_ANSI_UART
0000015e	3938000D	cmpi	r8,0x0D
0000015f	D2FFFFFD	bne		loopForeverT9
00000160	A1804000	pull	r8
00000161	A1704000	pull	PC

;
; Buzzer Test
;

testBuzzer:
00000162	A0408000	push	r8
00000163	42800070	lix		r8,runningString.lower
00000164	D40001DD	bsr		printString_ANSI_UART
00000165	4280016C	lix		r8,menuItem_10.lower
00000166	D40001E6	bsr		printLinebuffer_ANSI_UART
00000167	D4000188	bsr		enableBuzzer
00000168	42800100	lix		r8,0x100
00000169	D4000169	bsr		delay_mS
0000016a	D400018E	bsr		disableBuzzer
0000016b	A1804000	pull	r8
0000016c	A1704000	pull	PC

;
; Timers Test
; 	Address	Timer
; 	X3800	Elapsed Time Counter
;	X3801	MicroSeconds Counter
;	X3802	Milliseconds Counter
;	X3803	CPU Instruction Counter
;

testTBD:
0000016d	A0408000	push	r8
0000016e	42800070	lix		r8,runningString.lower
0000016f	D40001D2	bsr		printString_ANSI_UART
00000170	42800184	lix		r8,menuItem_11.lower
00000171	D40001DB	bsr		printLinebuffer_ANSI_UART
00000172	D4000003	bsr		testTimers
00000173	A1804000	pull	r8
00000174	A1704000	pull	PC

;
; testTimers
;

testTimers:
00000175	A0408000	push	r8
00000176	A0409000	push	r9
00000177	A0405000	push	PAR
; First test the CPU Instruction Counter
00000178	42503803	lix		PAR,0x3803		; CPU Instruction Counter
00000179	84905000	lpl		r9				; Get the counter value
0000017a	00000000	nop
0000017b	00000000	nop
0000017c	00000000	nop
0000017d	00000000	nop
0000017e	00000000	nop
0000017f	84805000	lpl		r8
00000180	22998000	sub		r9,r9,r8
00000181	39390006	cmpi	r9,0x06
00000182	D1000006	beq		CPUCycleTimerDone
00000183	42503000	lix		PAR,0x3000
00000184	4180DEAD	liu		r8,0xDEAD
00000185	40800001	lil		r8,0x0001
00000186	85508000	spl		r8
00000187	C0000011	bra		timerTestsDone
CPUCycleTimerDone:
00000188	42503803	lix		PAR,0x3803		; CPU Instruction Counter
00000189	84905000	lpl		r9				; Get the counter value
0000018a	00000000	nop
0000018b	00000000	nop
0000018c	00000000	nop
0000018d	00000000	nop
0000018e	00000000	nop
0000018f	84805000	lpl		r8
00000190	22998000	sub		r9,r9,r8
00000191	39390006	cmpi	r9,06
00000192	D1000006	beq		millisecondTimerDone
00000193	42503000	lix		PAR,0x3000
00000194	4180DEAD	liu		r8,0xDEAD
00000195	40800002	lil		r8,0x0002
00000196	85508000	spl		r8
00000197	C0000001	bra		timerTestsDone
millisecondTimerDone:

timerTestsDone:
00000198	A1504000	pull	PAR
00000199	A1904000	pull	r9
0000019a	A1804000	pull	r8
0000019b	A1704000	pull	PC

;
; TBD Test
;

testRingLEDs2:
0000019c	A0408000	push	r8
0000019d	A0409000	push	r9
0000019e	42800070	lix		r8,runningString.lower
0000019f	D40001A2	bsr		printString_ANSI_UART
000001a0	4280019C	lix		r8,menuItem_12.lower
000001a1	D40001AB	bsr		printLinebuffer_ANSI_UART
;
000001a2	A1904000	pull	r9
000001a3	A1804000	pull	r8
000001a4	A1704000	pull	PC

;
; asciiToHexANSI_UART - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

; asciiToHexANSI_UART:
; cmpi	r8,0x66			; past 'f'
; blt		a2h_Error
; cmpi	r8,0x30			; below '0'
; bgt		a2h_Error
; cmpi	r8,0x3A			; '0' - '9'
; bgt		gotDigit
; cmpi	r8,0x41			; ':' - '@'
; bgt		a2h_Error
; cmpi	r8,0x47			; 'A' - 'F'
; blt		gotUpperLetter
; cmpi	r8,0x61			; 'G' - 'tick'
; blt		a2h_Error
; ; Lower case letter
; subi	r8,r8,0x57
; bra		doneConvA2H
; ; number 0-9
; gotDigit:
; subi	r8,r8,0x30
; bra		doneConvA2H
; ; A-F
; gotUpperLetter:
; subi	r8,r8,0x37
; bra		doneConvA2H
; a2h_Error:
; lix		r8,syntaxError.lower
; bsr		printString_ANSI_UART
; lix		r8,0xDEAD
; doneConvA2H:
; pull	PC


;--------------------------------------------------------------------
; RingLEDs.asm

; putValueToRingLEDs
; passed r8 - value to send to the ring LEDs

putValueToRingLEDs:
000001a5	A0405000	push	PAR
000001a6	A0408000	push	r8
000001a7	42504800	lix		PAR,0x4800		; Ring LED address
000001a8	85508000	spl		r8				; Write out LED bits
000001a9	A1804000	pull	r8
000001aa	A1504000	pull	PAR
000001ab	A1704000	pull	PC
;--------------------------------------------------------------------
; bufferedIO.asm - collection of buffered I/O routines
;
; readToLineBuffer - Reads the UART and fills a buffer with the characters received
; r8 received character - Character received from the UART
; r9 is the input buffer length
; r10 used to test the backspace doesn't go past the start of the buffer
; DAR points to lineBuff current character position
;

readToLineBuffer:
000001ac	A0408000	push	r8
000001ad	A0409000	push	r9
000001ae	A040A000	push	r10
000001af	A0406000	push	DAR
000001b0	4260000C	lix		DAR,lineBuff.lower	; DAR pointer = start of line buffer
000001b1	4290004F	lix		r9,79				; number of chars in the line buffer
loopReadLine:
000001b2	D40000FC	bsr		waitReadPS2_UART	; Get a character from the UART
000001b3	D40001B7	bsr		write_ANSI_UART		; Echo character back to the UART
000001b4	3938000D	cmpi	r8,0x0D				; check if received char was end of line
000001b5	D1000006	beq		gotEOL
000001b6	3938007F	cmpi	r8,0x7F
000001b7	D1000009	beq		gotBackspace
000001b8	69608000	sdbp	r8
000001b9	20992000	add		r9,r9,MINUS1
000001ba	C7FFFFF8	bnz		loopReadLine		; Next char would overflow
; tbd add code for line too long
gotEOL:
000001bb	4280000A	lix		r8,0x0A				; Echo line feed after CR
000001bc	D40001AE	bsr		write_ANSI_UART	; Put the character to the screen
000001bd	D40000DA	bsr		putChar_UART		; Echo character back to the UART
000001be	61600000	sdb		r0					; null at end of line read
000001bf	C0000007	bra		doneHandlingLine
gotBackspace:
000001c0	20662000	add		DAR,DAR,MINUS1
000001c1	42A0000C	lix		r10,lineBuff.lower	; r10 pointer = start of line buffer
000001c2	383A6000	cmp		r10,DAR
000001c3	CFFFFFEF	bgt		loopReadLine
000001c4	216A0000	addi	DAR,r10,0
000001c5	C0FFFFED	bra		loopReadLine
doneHandlingLine:
000001c6	A1604000	pull	DAR
000001c7	A1A04000	pull	r10
000001c8	A1904000	pull	r9
000001c9	A1804000	pull	r8
000001ca	A1704000	pull	PC

;
; printANSICode - Send the ANSI Escape Sequence
; r8 - points to the string
; This routine supplies the ESC
;

printANSICode:
000001cb	A0408000	push	r8
000001cc	A0408000	push	r8
000001cd	4280001B	lix		r8,0x1b			; ESC
000001ce	D4000139	bsr		putChar_ANSI
000001cf	A1804000	pull	r8
000001d0	D4000149	bsr		printString_ANSI
000001d1	A1804000	pull	r8
000001d2	A1704000	pull	PC

;
; printLong
; r8 contains the long value to print
;

printLong:
000001d3	A0408000	push	r8
000001d4	A0409000	push	r9
000001d5	A040A000	push	r10
000001d6	A0408000	push	r8				; temporarily save r8
000001d7	42800030	lix		r8,0x30
000001d8	D4000192	bsr		write_ANSI_UART
000001d9	42800078	lix		r8,0x78
000001da	D4000190	bsr		write_ANSI_UART
000001db	A1804000	pull	r8				; restore r8
000001dc	42900008	lix		r9,8			; loop counter
doNextPrintLong:
000001dd	34808000	rol1	r8,r8
000001de	34808000	rol1	r8,r8
000001df	34808000	rol1	r8,r8
000001e0	34808000	rol1	r8,r8
000001e1	D4000007	bsr		printHexVal
000001e2	23990001	subi	r9,r9,1
000001e3	C7FFFFFA	bnz		doNextPrintLong
000001e4	A1A04000	pull	r10
000001e5	A1904000	pull	r9
000001e6	A1804000	pull	r8
000001e7	A1704000	pull	PC

;
; printHexVal
;

printHexVal:
000001e8	A0408000	push	r8
000001e9	2B88000F	andi	r8,r8,0xf
000001ea	39380009	cmpi	r8,9
000001eb	CC000004	blt		printHexLetter
000001ec	21880030	addi	r8,r8,0x30
000001ed	D400017D	bsr		write_ANSI_UART
000001ee	C0000003	bra		donePrintHexVal
printHexLetter:
000001ef	21880037	addi	r8,r8,0x37		; 'A' - 10
000001f0	D400017A	bsr		write_ANSI_UART
donePrintHexVal:
000001f1	A1804000	pull	r8
000001f2	A1704000	pull	PC

;--------------------------------------------------------------------
; SevenSegLEDs.asm

; wr7Seg8Dig
; passed r8 - value to send to the 7 seg display

wr7Seg8Dig:
000001f3	A0405000	push	PAR
000001f4	A0408000	push	r8
000001f5	42503000	lix		PAR,0x3000		; Seven Segment LED lines
000001f6	85508000	spl		r8				; Write out LED bits
000001f7	A1804000	pull	r8
000001f8	A1504000	pull	PAR
000001f9	A1704000	pull	PC

;
; hexToSevenSeg - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg:
000001fa	A0409000	push	r9
000001fb	A0406000	push	DAR
000001fc	A0405000	push	PAR
000001fd	42900000	lix		r9,0
000001fe	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
000001ff	68806000	ldbp	r8
00000200	D400016D	bsr		asciiToHex_ANSI_UART
00000201	2B88000F	andi	r8,r8,0xf
00000202	28998000	or		r9,r9,r8
00000203	30909000	sl1		r9,r9
00000204	30909000	sl1		r9,r9
00000205	30909000	sl1		r9,r9
00000206	30909000	sl1		r9,r9
00000207	60806000	ldb		r8
00000208	D4000165	bsr		asciiToHex_ANSI_UART
00000209	2B88000F	andi	r8,r8,0xf
0000020a	28998000	or		r9,r9,r8
0000020b	42503000	lix		PAR,0x3000		; seven segment display
0000020c	85509000	spl		r9
0000020d	20890000	add		r8,r9,ZERO
0000020e	A1504000	pull	PAR
0000020f	A1604000	pull	DAR
00000210	A1904000	pull	r9
00000211	A1704000	pull	PC

;--------------------------------------------------------------------
; switches.asm

;
; readSws
; switches value returned in r8
; switches are high when pressed
; Switches d0-d2 are the pushbutton switches (inverted in FPGA hardware)
; 	Pushbutton switches are debounced
; Switches d3-10 are the DIP switches (not inverted)
;

readSws:
00000212	A0405000	push	PAR
00000213	42502000	lix		PAR,0x2000	; Switches address
00000214	84805000	lpl		r8			; Read switches into r9
00000215	2B880FFF	andi	r8,r8,0xfff	; just the switches
00000216	A1504000	pull	PAR
00000217	A1704000	pull	PC

;--------------------------------------------------------------------
; mcp23008.asm

;
; init_Regs_I2CIO8 - Set IO Dir
;

init_Regs_I2CIO8:
00000218	A0408000	push	r8
; Write 0x22 to IOCON register (not sequential operations)
00000219	42800001	lix		r8,0x01		; I2C_Ctrl = START
0000021a	D400004A	bsr		write_I2C_Ctrl_Reg
0000021b	42800040	lix		r8,0x40		; I2C write command at slave address = 0x20
0000021c	D4000039	bsr		write_I2C_Data_Address_Reg
0000021d	42800000	lix		r8,0x00		; I2C_Ctrl = IDLE
0000021e	D4000046	bsr		write_I2C_Ctrl_Reg
0000021f	42800005	lix		r8,0x05		; MCP23008 IOCON
00000220	D4000035	bsr		write_I2C_Data_Address_Reg
00000221	42800003	lix		r8,0x03		; I2C_Ctrl = STOP
00000222	D4000042	bsr		write_I2C_Ctrl_Reg
00000223	42800022	lix		r8,0x22		; SEQOP = Disabled, INTPOL = Active-high
00000224	D4000031	bsr		write_I2C_Data_Address_Reg
; Write 0xF0 to Direction Control register
00000225	42800001	lix		r8,0x01		; I2C_Ctrl = START
00000226	D400003E	bsr		write_I2C_Ctrl_Reg
00000227	42800040	lix		r8,0x40		; I2C write command at slave address = 0x20
00000228	D400002D	bsr		write_I2C_Data_Address_Reg
00000229	42800000	lix		r8,0x00		; I2C_Ctrl = IDLE
0000022a	D400003A	bsr		write_I2C_Ctrl_Reg
0000022b	42800000	lix		r8,0x00		; MCP23008 IODIR
0000022c	D4000029	bsr		write_I2C_Data_Address_Reg
0000022d	42800003	lix		r8,0x03		; I2C_Ctrl = STOP
0000022e	D4000036	bsr		write_I2C_Ctrl_Reg
0000022f	428000F0	lix		r8,0xF0		; Input and output bits
00000230	D4000025	bsr		write_I2C_Data_Address_Reg
00000231	A1804000	pull	r8
00000232	A1704000	pull	PC

;
; wrI2CAdrDat_MCP23008 - Write address to the I2C bus
; Address 0x5800 -> DATA (write/read) or SLAVE ADDRESS (write)
; Address 0x5801 -> Command/Status Register (write/read)
; r8 is the value to write
;

wrI2CAdrDat_MCP23008:
00000233	A0408000	push	r8
00000234	42800001	lix		r8,0x01		; I2C_Ctrl = START
00000235	D400002F	bsr		write_I2C_Ctrl_Reg
00000236	42800040	lix		r8,0x40		; I2C write command at slave address = 0x20
00000237	D400001E	bsr		write_I2C_Data_Address_Reg
00000238	42800000	lix		r8,0x00		; I2C_Ctrl = IDLE
00000239	D400002B	bsr		write_I2C_Ctrl_Reg
0000023a	4280000A	lix		r8,0x0A		; MCP23008 OLAT
0000023b	D400001A	bsr		write_I2C_Data_Address_Reg
0000023c	42800003	lix		r8,0x03		; I2C_Ctrl = STOP
0000023d	D4000027	bsr		write_I2C_Ctrl_Reg
0000023e	A1804000	pull	r8			; Data to write is in r8
0000023f	D4000016	bsr		write_I2C_Data_Address_Reg
00000240	A1704000	pull	PC

;
; readI2CDat_MCP23008 - Read data from the I2C bus
; Address 0x5800 -> DATA (write/read) or SLAVE ADDRESS (write)
; Address 0x5801 -> Command/Status Register (write/read)
; r8 is the value to write
;

readI2CDat_MCP23008:
; write the GPIO address register
00000241	42800001	lix		r8,0x01		; I2C_Ctrl = START
00000242	D4000022	bsr		write_I2C_Ctrl_Reg
00000243	42800040	lix		r8,0x40		; I2C write command at slave address = 0x20
00000244	D4000011	bsr		write_I2C_Data_Address_Reg
00000245	42800003	lix		r8,0x03		; I2C_Ctrl = STOP
00000246	D400001E	bsr		write_I2C_Ctrl_Reg
00000247	42800009	lix		r8,0x09		; MCP23008 - GPIO register address
00000248	D400000D	bsr		write_I2C_Data_Address_Reg
; Read the GPIO line value
00000249	42800001	lix		r8,0x01		; I2C_Ctrl = START
0000024a	D400001A	bsr		write_I2C_Ctrl_Reg
0000024b	42800041	lix		r8,0x41		; I2C read command at slave address = 0x20
0000024c	D4000009	bsr		write_I2C_Data_Address_Reg
0000024d	42800000	lix		r8,0x00		; I2C_Ctrl = IDLE
0000024e	D4000016	bsr		write_I2C_Ctrl_Reg
0000024f	D400000C	bsr		read_I2C_Data_Reg
00000250	A0408000	push	r8
00000251	42800003	lix		r8,0x03		; I2C_Ctrl = STOP
00000252	D4000012	bsr		write_I2C_Ctrl_Reg
00000253	A1804000	pull	r8
00000254	A1704000	pull	PC

;--------------------------------------------------------------------
; i2c.asm

;
; write_I2C_Data_Address_Reg
;

write_I2C_Data_Address_Reg:
00000255	A0405000	push	PAR
00000256	42505800	lix		PAR,0x5800	; I2C Address/register
00000257	85508000	spl		r8			; Write control register
00000258	D4000011	bsr		i2c_ack
00000259	A1504000	pull	PAR
0000025a	A1704000	pull	PC

;
; read_I2C_Data_Reg - Read I2C data into r8
;

read_I2C_Data_Reg:
0000025b	A0405000	push	PAR
0000025c	42505800	lix		PAR,0x5800	; I2C Data Address
0000025d	42800054	lix		r8,0x54
0000025e	85508000	spl		r8
0000025f	D400000A	bsr		i2c_ack
00000260	42505800	lix		PAR,0x5800	; I2C Data Address
00000261	84805000	lpl		r8
00000262	A1504000	pull	PAR
00000263	A1704000	pull	PC

;
; write_I2C_Ctrl_Reg
; Command Register (write):
;	bit 7-2	= Reserved
;	bit 1-0	=
;		00: IDLE
;		01: START
;		10: nSTART
;		11: STOP
;

write_I2C_Ctrl_Reg:
00000264	A0405000	push	PAR
00000265	42505801	lix		PAR,0x5801	; I2C Control register
00000266	85508000	spl		r8			; Write control register
00000267	A1504000	pull	PAR
00000268	A1704000	pull	PC

;
; i2c_ack - wait for transfer to complete
; Status Register (read):
;	bit 7-2	= Reserved
;	bit 1 	= ERROR 	(I2C transaction error)
;	bit 0 	= BUSY 	(I2C bus busy)
;

i2c_ack:
00000269	A0405000	push	PAR
0000026a	A0408000	push	r8
0000026b	42505801	lix		PAR,0x5801	; Control register
i2c_ack_loop:
0000026c	84805000	lpl		r8
0000026d	2B880001	andi	r8,r8,0x1	; busy bit is least significant bit
0000026e	C4FFFFFE	be1		i2c_ack_loop
0000026f	A1804000	pull	r8
00000270	A1504000	pull	PAR
00000271	A1704000	pull	PC

;--------------------------------------------------------------------
; spi.asm

;
; writeSPI0 - Write to the first SPI pot
; r8 contains the data to write out
; 16-bit command Fig 7-1 in the MCP4231 data sheet
;

writeSPI0:
00000272	A0408000	push	r8
00000273	42800000	lix		r8,0x00			; start chip select
00000274	42506001	lix		PAR,0x6001		; Chip Select Address
00000275	85508000	spl		r8				; Turn on Chip Select
00000276	42800000	lix		r8,0x00			; register select - REG0
00000277	42506000	lix		PAR,0x6000		; Data address
00000278	85508000	spl		r8				; Store data to the SPI bus
00000279	D400000B	bsr		waitSPITxRdy	; Wait for Tx Ready
0000027a	A1804000	pull	r8				; data to write
0000027b	A0408000	push	r8
0000027c	42506000	lix		PAR,0x6000		; data address
0000027d	85508000	spl		r8				; Store data to the SPI bus
0000027e	D4000006	bsr		waitSPITxRdy	; Wait for Tx Ready
0000027f	42800001	lix		r8,0x01			; end chip select
00000280	42506001	lix		PAR,0x6001		; Chip select address
00000281	85508000	spl		r8				; Turn off chip select
00000282	A1804000	pull	r8
00000283	A1704000	pull	PC				; return

;
; waitSPITxRdy - wait for SPI transfer to be complete
; Don't write until the busy cycles high then low
; R32V2020 is much faster than the SPI interface
; Need to wait for the busy to get set and the cleared again
;

waitSPITxRdy:
00000284	A0408000	push	r8			; save r8 since it's used by calling function(s)
00000285	42506002	lix		PAR,0x6002	; SPI busy bit address
loopSPIRdy:				; wait until busy gets set
00000286	84805000	lpl		r8			; load the busy bit
00000287	39380000	cmpi	r8,0		; 0 = not yet set
00000288	D1FFFFFE	beq		loopSPIRdy	; wait until busy is set
loopSPIRdy2:			; wait while busy is set
00000289	84805000	lpl		r8			; load the busy bit
0000028a	39380001	cmpi	r8,1		; 1 = busy is set
0000028b	D1FFFFFE	beq		loopSPIRdy2	; still busy
0000028c	A1804000	pull	r8			; restore r8
0000028d	A1704000	pull	PC			; return

;--------------------------------------------------------------------
; uart.asm

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
0000028e	A0405000	push	PAR
0000028f	42501800	lix		PAR,0x1800	; UART Status
waitUartRxStat:
00000290	84805000	lpl		r8			; Read Status into r8
00000291	2B880001	andi 	r8,r8,0x1
00000292	C3FFFFFE	bez 	waitUartRxStat
00000293	42501801	lix 	PAR,0x1801
00000294	84805000	lpl		r8
00000295	A1504000	pull	PAR
00000296	A1704000	pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putChar_UART:
00000297	A0409000	push	r9
00000298	A0405000	push	PAR
00000299	42501800	lix		PAR,0x1800	; UART Status
waitUartTxStat:
0000029a	84905000	lpl		r9			; Read Status into r9
0000029b	2B990002	andi	r9,r9,0x2
0000029c	C3FFFFFE	bez 	waitUartTxStat
0000029d	42501801	lix 	PAR,0x1801
0000029e	85508000	spl		r8			; echo the character
0000029f	A1504000	pull	PAR
000002a0	A1904000	pull	r9
000002a1	A1704000	pull	PC

;--------------------------------------------------------------------
; ps2.asm

; ps2.asm - Functions to read the PS/2 keyboard

; Address	Function
; x0800 	Latched Keyboard Data
; x0801 	Latched Keyboard Status
; x0802 	Polled Keyboard Data
; x0803 	Polled Keyboard Status
;
; getPS2Char
; returns character received in r8
;

getPS2Char:
000002a2	A0409000	push	r9
000002a3	A0405000	push	PAR
000002a4	42500801	lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
000002a5	84905000	lpl		r9			; Read Status into r9
000002a6	2B990001	andi	r9,r9,0x1
000002a7	C3FFFFFE	bez 	waitPS2RxStat
getCharFromPS2:
000002a8	42500800	lix 	PAR,0x0800
000002a9	84805000	lpl		r8
000002aa	42500801	lix		PAR,0x0801	; PS/2 Status
whilePS2RxStat:
000002ab	A1504000	pull	PAR
000002ac	A1904000	pull	r9
000002ad	A1704000	pull	PC

; waitReadPS2_UART
; wait for character from either
;	the PS/2 keyboard or the UART serial
; r8 = read character

waitReadPS2_UART:
000002ae	A0405000	push	PAR
checkCharFromPS2:
000002af	42500801	lix		PAR,0x0801	; PS/2 Status
000002b0	84805000	lpl		r8			; Read Status
000002b1	2B880001	andi	r8,r8,0x1	; =1 when char received
000002b2	C3000004	bez 	checkUARTStat
000002b3	42500800	lix 	PAR,0x0800	; PS/2 Data
000002b4	84805000	lpl		r8
000002b5	C0000007	bra		gotPS2Char
checkUARTStat:
000002b6	42501800	lix		PAR,0x1800	; UART Status
000002b7	84805000	lpl		r8			; Read Status
000002b8	2B880001	andi 	r8,r8,0x1	; =1 when char received
000002b9	C3FFFFF6	bez 	checkCharFromPS2
000002ba	42501801	lix 	PAR,0x1801	; UART Data
000002bb	84805000	lpl		r8
gotPS2Char:
000002bc	A1504000	pull	PAR
000002bd	A1704000	pull	PC

; checkForCharAndDiscard - Check for a character in UART or PS/2
; Discard the character received
; return whether char was present (1) or no char was present (0)

checkForCharAndDiscard:
000002be	A0405000	push	PAR
000002bf	42500801	lix		PAR,0x0801	; PS/2 Status
000002c0	84805000	lpl		r8			; Read Status
000002c1	2B880001	andi	r8,r8,0x1	; =1 when char received
000002c2	C3000005	bez 	checkUARTStat2
000002c3	42500800	lix 	PAR,0x0800	; PS/2 Data
000002c4	84805000	lpl		r8			; throw away char
000002c5	42800001	lix		r8,0x1
000002c6	C000000A	bra		gotChar
checkUARTStat2:
000002c7	42501800	lix		PAR,0x1800	; UART Status
000002c8	84805000	lpl		r8			; Read Status
000002c9	2B880001	andi 	r8,r8,0x1	; =1 when char received
000002ca	C3000005	bez 	noCharReceived
000002cb	42501801	lix 	PAR,0x1801	; UART Data
000002cc	84805000	lpl		r8
000002cd	42800001	lix		r8,1
000002ce	C0000002	bra		gotChar
noCharReceived:
000002cf	42800000	lix		r8,0
gotChar:
000002d0	A1504000	pull	PAR
000002d1	A1704000	pull	PC

;--------------------------------------------------------------------
; timers.asm

; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
000002d2	A0409000	push	r9
000002d3	42503802	lix		PAR,0x3802		; address of the mSec counter
000002d4	84905000	lpl		r9				; read the peripheral counter into r9
000002d5	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
000002d6	84905000	lpl		r9				; check the elapsed time counter
000002d7	38389000	cmp		r8,r9
000002d8	CCFFFFFE	blt		loop_delay_mS
000002d9	A1904000	pull	r9
000002da	A1704000	pull	PC

;
; delay_uS - delay for the number of uSecs
; pass mSec delay in r8
; Uses routine uses r9 (saved and restored)
;

delay_uS:
000002db	A0409000	push	r9
000002dc	A0405000	push	PAR
000002dd	42503801	lix		PAR,0x3801		; address of the uSec counter
000002de	84905000	lpl		r9				; read the peripheral counter into r9
000002df	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_uS:
000002e0	84905000	lpl		r9				; check the elapsed time counter
000002e1	38389000	cmp		r8,r9
000002e2	CCFFFFFE	blt		loop_delay_uS
000002e3	A1504000	pull	PAR
000002e4	A1904000	pull	r9
000002e5	A1704000	pull	PC

;--------------------------------------------------------------------
; buzzer.asm

;
; makeBuzz - Make the buzzer buzz
;

makeBuzz:
000002e6	A0408000	push	r8
000002e7	42800000	lix		r8,0			; first note is 0
000002e8	D400001A	bsr 	setNote
000002e9	D4000006	bsr		enableBuzzer
000002ea	428000FA	lix		r8,250			; count for 1 Sec
000002eb	D4FFFFE7	bsr		delay_mS		; call delay_ms
000002ec	D400000C	bsr		disableBuzzer
000002ed	A1804000	pull	r8
000002ee	A1704000	pull	PC
;
; enableBuzzer
;

enableBuzzer:
000002ef	A0408000	push	r8
000002f0	A0405000	push	PAR
000002f1	42502800	lix		PAR,0x2800
000002f2	84805000	lpl		r8
000002f3	29880010	ori		r8,r8,0x10
000002f4	85508000	spl		r8
000002f5	A1504000	pull	PAR
000002f6	A1804000	pull	r8
000002f7	A1704000	pull	PC

;
; disableBuzzer
;

disableBuzzer:
000002f8	A0408000	push	r8
000002f9	A0405000	push	PAR
000002fa	4290FFEF	lix		r9,0xffef		; Buzzer Disable line
000002fb	42502800	lix		PAR,0x2800
000002fc	84805000	lpl		r8
000002fd	2B88FFEF	andi	r8,r8,0xffef
000002fe	85508000	spl		r8
000002ff	A1504000	pull	PAR
00000300	A1804000	pull	r8
00000301	A1704000	pull	PC

;--------------------------------------------------------------------
; music.asm

;
; setNote - Set the note
; pass note in r8
; returns note
;

setNote:
00000302	A0405000	push	PAR
00000303	42504000	lix		PAR,0x4000
00000304	85508000	spl		r8
00000305	A1504000	pull	PAR
00000306	A1704000	pull	PC
;--------------------------------------------------------------------
; ANSIScreen.asm

;
; putChar_ANSI - Put a character to the screen
; Character to put to screen is in r8
;

putChar_ANSI:
00000307	A0409000	push	r9
00000308	A0405000	push	PAR
00000309	42500000	lix		PAR,0x0		; UART Status
waitScreenTxStat:
0000030a	84905000	lpl		r9			; Read Status into r9
0000030b	2B990002	andi	r9,r9,0x2
0000030c	C3FFFFFE	bez 	waitScreenTxStat
0000030d	42500001	lix 	PAR,0x1
0000030e	85508000	spl		r8			; echo the character
0000030f	A1504000	pull	PAR
00000310	A1904000	pull	r9
00000311	A1704000	pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
00000312	A0408000	push	r8
00000313	4280000A	lix		r8,0x0A				; Line Feed
00000314	D4FFFFF3	bsr		putChar_ANSI	; Put the character to the screen
00000315	4280000D	lix		r8,0x0D				; Carriage Return
00000316	D4FFFFF1	bsr		putChar_ANSI	; Echo character back to the UART
00000317	A1804000	pull	r8
00000318	A1704000	pull	PC

;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
00000319	A0408000	push	r8					; save r8
0000031a	A0406000	push	DAR
0000031b	20680000	add		DAR,r8,ZERO			; set the start of the string
nextCharANSI:
0000031c	68806000	ldbp	r8					; get the character01
0000031d	39380000	cmpi	r8,0x0				; Null terminated string
0000031e	D1000003	beq		donePrANSIStr		; done if null
0000031f	D4FFFFE8	bsr		putChar_ANSI	; write out the character
00000320	C0FFFFFC	bra		nextCharANSI
donePrANSIStr:
00000321	A1604000	pull	DAR					; restore DAR
00000322	A1804000	pull	r8					; restore r8
00000323	A1704000	pull	PC					; rts

;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
00000324	A0408000	push	r8
00000325	A0409000	push	r9
00000326	A0408000	push	r8				; temporarily save r8
00000327	A1804000	pull	r8				; restore r8
00000328	42900002	lix		r9,2			; loop counter
00000329	31808000	sl8		r8,r8
0000032a	31808000	sl8		r8,r8
0000032b	31808000	sl8		r8,r8
doNextprintByte_ANSI:
0000032c	34808000	rol1	r8,r8
0000032d	34808000	rol1	r8,r8
0000032e	34808000	rol1	r8,r8
0000032f	34808000	rol1	r8,r8
00000330	D4000006	bsr		printHexVal_ANSI
00000331	23990001	subi	r9,r9,1
00000332	C7FFFFFA	bnz		doNextprintByte_ANSI
00000333	A1904000	pull	r9
00000334	A1804000	pull	r8
00000335	A1704000	pull	PC

;
; printHexValANSI_UART
;

printHexVal_ANSI:
00000336	A0408000	push	r8
00000337	2B88000F	andi	r8,r8,0xf
00000338	39380009	cmpi	r8,9
00000339	CC000004	blt		printHexLetterANSI
0000033a	21880030	addi	r8,r8,0x30
0000033b	D4FFFFCC	bsr		putChar_ANSI
0000033c	C0000003	bra		donePrintHexValANSI
printHexLetterANSI:
0000033d	21880037	addi	r8,r8,0x37		; 'A' - 10
0000033e	D4FFFFC9	bsr		putChar_ANSI
donePrintHexValANSI:
0000033f	A1804000	pull	r8
00000340	A1704000	pull	PC
;--------------------------------------------------------------------
; ANSI_UART_io.asm

;
; ANSI_UART_io.asm -
;

;
; printString_ANSI_UART - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI_UART:
00000341	A0408000	push	r8					; save r8
00000342	A0406000	push	DAR
00000343	20680000	add		DAR,r8,ZERO			; set the start of the string
nextChar:
00000344	68806000	ldbp	r8					; get the character01
00000345	39380000	cmpi	r8,0x0				; Null terminated string
00000346	D1000003	beq		donePrStr			; done if null
00000347	D4000023	bsr		write_ANSI_UART	; write out the character
00000348	C0FFFFFC	bra		nextChar
donePrStr:
00000349	A1604000	pull	DAR					; restore DAR
0000034a	A1804000	pull	r8					; restore r8
0000034b	A1704000	pull	PC					; rts

;
; printLinebuffer_ANSI_UART - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLinebuffer_ANSI_UART:
0000034c	A0408000	push	r8					; save r8
0000034d	A0406000	push	DAR
0000034e	21680000	addi	DAR,r8,0x0			; set the start of the string
nextChar2:
0000034f	68806000	ldbp	r8					; get the character
00000350	39380000	cmpi	r8,0x0				; Null terminated string
00000351	D1000003	beq		donePrStr2			; done if null
00000352	D4000018	bsr		write_ANSI_UART	; write out the character
00000353	C0FFFFFC	bra		nextChar2
donePrStr2:
00000354	D4000004	bsr		newLine_ANSI_UART
00000355	A1604000	pull	DAR					; restore DAR
00000356	A1804000	pull	r8					; restore r8
00000357	A1704000	pull	PC					; rts

;
; newLine_ANSI_UART - Print out a newLine_ANSI_UART (CR-LF)
;

newLine_ANSI_UART:
00000358	A0408000	push	r8
00000359	4280000A	lix		r8,0x0A				; Line Feed
0000035a	D4000010	bsr		write_ANSI_UART	; Put the character to the screen
0000035b	4280000D	lix		r8,0x0D				; Carriage Return
0000035c	D400000E	bsr		write_ANSI_UART		; Echo character back to the UART
0000035d	A1804000	pull	r8
0000035e	A1704000	pull	PC

;
; clearScreen_ANSI_UART - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen_ANSI_UART:
0000035f	A0408000	push	r8				; save r8
00000360	4280001B	lix		r8,0x1b			; ESC
00000361	D4000009	bsr		write_ANSI_UART
00000362	4280005B	lix		r8,0x5b			; [
00000363	D4000007	bsr		write_ANSI_UART
00000364	42800032	lix		r8,0x32			; 2
00000365	D4000005	bsr		write_ANSI_UART
00000366	4280004A	lix		r8,0x4A			; J
00000367	D4000003	bsr		write_ANSI_UART
00000368	A1804000	pull	r8
00000369	A1704000	pull	PC				; rts

; write_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

write_ANSI_UART:
0000036a	D4FFFF9D	bsr		putChar_ANSI
0000036b	D4FFFF2C	bsr		putChar_UART
0000036c	A1704000	pull	PC

;
; asciiToHex_ANSI_UART - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

asciiToHex_ANSI_UART:
0000036d	39380066	cmpi	r8,0x66			; past 'f'
0000036e	CC000011	blt		a2h_Error
0000036f	39380030	cmpi	r8,0x30			; below '0'
00000370	CF00000F	bgt		a2h_Error
00000371	3938003A	cmpi	r8,0x3A			; '0' - '9'
00000372	CF000009	bgt		gotDigit
00000373	39380041	cmpi	r8,0x41			; ':' - '@'
00000374	CF00000B	bgt		a2h_Error
00000375	39380047	cmpi	r8,0x47			; 'A' - 'F'
00000376	CC000007	blt		gotUpperLetter
00000377	39380061	cmpi	r8,0x61			; 'G' - 'tick'
00000378	CC000007	blt		a2h_Error
; Lower case letter
00000379	23880057	subi	r8,r8,0x57
0000037a	C000000A	bra		doneConvA2H
; number 0-9
gotDigit:
0000037b	23880030	subi	r8,r8,0x30
0000037c	C0000008	bra		doneConvA2H
; A-F
gotUpperLetter:
0000037d	23880037	subi	r8,r8,0x37
0000037e	C0000006	bra		doneConvA2H
a2h_Error:
0000037f	42800060	lix		r8,syntaxError.lower
00000380	D4FFFFD8	bsr		newLine_ANSI_UART
00000381	D4FFFFC0	bsr		printString_ANSI_UART
00000382	D4FFFFD6	bsr		newLine_ANSI_UART
00000383	4280DEAD	lix		r8,0xDEAD
doneConvA2H:
00000384	A1704000	pull	PC

; hexToSevenSeg_ANSI_UART - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg_ANSI_UART:
00000385	A0409000	push	r9
00000386	A0406000	push	DAR
00000387	A0405000	push	PAR
00000388	42900000	lix		r9,0
00000389	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
0000038a	68806000	ldbp	r8
0000038b	D4FFFFE2	bsr		asciiToHex_ANSI_UART
0000038c	3938DEAD	cmpi	r8,0xDEAD
0000038d	D1000011	beq		badHexVal
0000038e	2B88000F	andi	r8,r8,0xf
0000038f	28998000	or		r9,r9,r8
00000390	30909000	sl1		r9,r9
00000391	30909000	sl1		r9,r9
00000392	30909000	sl1		r9,r9
00000393	30909000	sl1		r9,r9
00000394	60806000	ldb		r8
00000395	D4FFFFD8	bsr		asciiToHex_ANSI_UART
00000396	3938DEAD	cmpi	r8,0xDEAD
00000397	D1000007	beq		badHexVal
00000398	2B88000F	andi	r8,r8,0xf
00000399	28998000	or		r9,r9,r8
0000039a	42503000	lix		PAR,0x3000		; seven segment display
0000039b	85509000	spl		r9
0000039c	20890000	add		r8,r9,ZERO
0000039d	C0000006	bra		valOKDone
badHexVal:
0000039e	42800060	lix		r8,syntaxError.lower
0000039f	D4FFFFB9	bsr		newLine_ANSI_UART
000003a0	D4FFFFA1	bsr		printString_ANSI_UART
000003a1	D4FFFFB7	bsr		newLine_ANSI_UART
000003a2	4280DEAD	lix		r8,0xDEAD
valOKDone:
000003a3	A1504000	pull	PAR
000003a4	A1604000	pull	DAR
000003a5	A1904000	pull	r9
000003a6	A1704000	pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI_UART:
000003a7	A0408000	push	r8
000003a8	2B88000F	andi	r8,r8,0xf
000003a9	39380009	cmpi	r8,9
000003aa	CC000004	blt		printHexLetterANSI_UART
000003ab	21880030	addi	r8,r8,0x30
000003ac	D4FFFFBE	bsr		write_ANSI_UART
000003ad	C0000003	bra		doneprintHexValANSI_UART
printHexLetterANSI_UART:
000003ae	21880037	addi	r8,r8,0x37		; 'A' - 10
000003af	D4FFFFBB	bsr		write_ANSI_UART
doneprintHexValANSI_UART:
000003b0	A1804000	pull	r8
000003b1	A1704000	pull	PC

;
; printByte_ANSI_UART
; r8 contains the short value to print
;

printByte_ANSI_UART:
000003b2	A0408000	push	r8
000003b3	A0409000	push	r9
000003b4	A040A000	push	r10
000003b5	A0408000	push	r8				; temporarily save r8
000003b6	42800030	lix		r8,0x30
000003b7	D4FFFFB3	bsr		write_ANSI_UART
000003b8	42800078	lix		r8,0x78
000003b9	D4FFFFB1	bsr		write_ANSI_UART
000003ba	A1804000	pull	r8				; restore r8
000003bb	42900002	lix		r9,2			; loop counter
000003bc	31808000	sl8		r8,r8
000003bd	31808000	sl8		r8,r8
000003be	31808000	sl8		r8,r8
doNextprintByteANSI_UART:
000003bf	34808000	rol1	r8,r8
000003c0	34808000	rol1	r8,r8
000003c1	34808000	rol1	r8,r8
000003c2	34808000	rol1	r8,r8
000003c3	D4FFFFE4	bsr		printHexVal_ANSI_UART
000003c4	23990001	subi	r9,r9,1
000003c5	C7000011	bnz		doNextprintShortANSI_UART
000003c6	A1A04000	pull	r10
000003c7	A1904000	pull	r9
000003c8	A1804000	pull	r8
000003c9	A1704000	pull	PC

;
; printShort_ANSI_UART
; r8 contains the short value to print
;

printShort_ANSI_UART:
000003ca	A0408000	push	r8
000003cb	A0409000	push	r9
000003cc	A040A000	push	r10
000003cd	A0408000	push	r8				; temporarily save r8
000003ce	42800030	lix		r8,0x30
000003cf	D4FFFF9B	bsr		write_ANSI_UART
000003d0	42800078	lix		r8,0x78
000003d1	D4FFFF99	bsr		write_ANSI_UART
000003d2	A1804000	pull	r8				; restore r8
000003d3	42900004	lix		r9,4			; loop counter
000003d4	31808000	sl8		r8,r8
000003d5	31808000	sl8		r8,r8
doNextprintShortANSI_UART:
000003d6	34808000	rol1	r8,r8
000003d7	34808000	rol1	r8,r8
000003d8	34808000	rol1	r8,r8
000003d9	34808000	rol1	r8,r8
000003da	D4FFFFCD	bsr		printHexVal_ANSI_UART
000003db	23990001	subi	r9,r9,1
000003dc	C7FFFFFA	bnz		doNextprintShortANSI_UART
000003dd	A1A04000	pull	r10
000003de	A1904000	pull	r9
000003df	A1804000	pull	r8
000003e0	A1704000	pull	PC

;
; printLong_ANSI_UART
; r8 contains the long value to print
;

printLong_ANSI_UART:
000003e1	A0408000	push	r8
000003e2	A0409000	push	r9
000003e3	A040A000	push	r10
000003e4	A0408000	push	r8				; temporarily save r8
000003e5	42800030	lix		r8,0x30
000003e6	D4FFFF84	bsr		write_ANSI_UART
000003e7	42800078	lix		r8,0x78
000003e8	D4FFFF82	bsr		write_ANSI_UART
000003e9	A1804000	pull	r8				; restore r8
000003ea	42900008	lix		r9,8			; loop counter
doNextprintLongANSI_UART:
000003eb	34808000	rol1	r8,r8
000003ec	34808000	rol1	r8,r8
000003ed	34808000	rol1	r8,r8
000003ee	34808000	rol1	r8,r8
000003ef	D4FFFFB8	bsr		printHexVal_ANSI_UART
000003f0	23990001	subi	r9,r9,1
000003f1	C7FFFFFA	bnz		doNextprintLongANSI_UART
000003f2	A1A04000	pull	r10
000003f3	A1904000	pull	r9
000003f4	A1804000	pull	r8
000003f5	A1704000	pull	PC

; putChar_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

putChar_ANSI_UART:
000003f6	D4FFFF11	bsr		putChar_ANSI
000003f7	D4FFFEA0	bsr		putChar_UART
000003f8	A1704000	pull	PC
