; P004-SD_Card_Test - Test the SD Card interface
; Not all FPGA cards have built-in SD Card sockets
; Can wire up to IO pins (if there are any)
;
; Original VHDL code was based on the Multicomp design by Grant Searle
; Enhanced by Neal Crook to support SDHC cards
; SDHC can be upto 32GByte but this design can only access the low 8GByte
; Code for R32V2020 RISC CPU
;
; SD Card base address is x1000
; Register Addresses
;    0x1000    SDDATA        read/write data
;    0x1001    SDSTATUS      read
;    0x1001    SDCONTROL     write
;    0x1002    SDLBA0        write-only
;    0x1003    SDLBA1        write-only
;    0x1004    SDLBA2        write-only (only bits 6:0 are valid)
;
; To read a 512-byte block from the SDCARD:
; Wait until SDSTATUS=0x80 (ensures previous cmd has completed)
; Write SDLBA0, SDLBA1 SDLBA2 to select block index to read from
; Write 0 to SDCONTROL to issue read command
; Loop 512 times:
;     Wait until SDSTATUS=0xE0 (read byte ready, block busy)
;     Read byte from SDDATA
;
; To write a 512-byte block to the SDCARD:
; Wait until SDSTATUS=0x80 (ensures previous cmd has completed)
; Write SDLBA0, SDLBA1 SDLBA2 to select block index to write to
; Write 1 to SDCONTROL to issue write command
; Loop 512 times:
;     Wait until SDSTATUS=0xA0 (block busy)
;     Write byte to SDDATA
;


prompt:	.string "R32V2020> "
missingHandshake: .string "*** Run PuTTY and enable hardware handshake ***"
screenPtr:	.long 0x0000
screenBase:	.long 0x0
syntaxError:	.string "*** Bad number error (at a2h_Error) ***"

;
; Read PS/2 character and put it to the SVGA Display and the Serial Port
;

main:
00000000	D4000061		bsr		clearScreen_ANSI
00000001	42800000		lix		r8,prompt.lower
00000002	D4000054		bsr		printString_ANSI
00000003	42800000		lix		r8,0					; read block 0 to start with
00000004	D4000002		bsr		readDumpBlock_SDCard
loopForever:
00000005	C0000000		bra		loopForever
	

;
; readBlock_SDCard
;
; To read a 512-byte block from the SDCARD:
; Wait until SDSTATUS=0x80 (ensures previous cmd has completed)
; Write SDLBA0, SDLBA1 SDLBA2 to select block index to read from
; Write 0 to SDCONTROL to issue read command
; Loop 512 times:
;     Wait until SDSTATUS=0xE0 (read byte ready, block busy)
;     Read byte from SDDATA
; r8 = Block number
;  31 30 29 28.27 26 25 24.23 22 21 20.19 18 17 16.15 14 13 12.11 10 09 08.07 06 05 04.03 02 01 00
; +------- SDLBA2 -----+------- SDLBA1 --------+------- SDLBA0 --------+ 0  0  0  0  0  0  0  0  0
;

readDumpBlock_SDCard:
00000006	A0408000		push	r8
00000007	A0409000		push	r9
00000008	A040A000		push	r10
00000009	A0405000		push	PAR
0000000a	42501001		lix		PAR,0x1001			; SDSTATUS
waitForSDStatusRdRdy:
0000000b	84905000		lpl		r9
0000000c	39390080		cmpi	r9,0x80
0000000d	D2FFFFFE		bne		waitForSDStatusRdRdy
0000000e	33808000		sr8		r8,r8				; Shift SD card block address right by 9 bits
0000000f	32808000		sr1		r8,r8
00000010	42501002		lix		PAR,0x1002
00000011	89508000		spbp	r8					; SDLBA0
00000012	33808000		sr8		r8,r8
00000013	89508000		spbp	r8					; SDLBA1
00000014	33808000		sr8		r8,r8
00000015	81508000		spb		r8					; SDLBA2
00000016	42900000		lix		r9,0
00000017	42501001		lix		PAR,0x1001			; SDCONTROL
00000018	81509000		spb		r9
00000019	42900200		lix		r9,512				; 512 characters to read
nextSDReadChar:
0000001a	42501001		lix		PAR,0x1001			; SDSTATUS
waitSDCharPresent:
0000001b	80A05000		lpb		r10
0000001c	393A00E0		cmpi	r10,0xE0
0000001d	D2FFFFFE		bne		waitSDCharPresent
0000001e	42501000		lix		PAR,0x1000			; SDDATA
0000001f	80805000		lpb		r8
00000020	D40000DA		bsr		printByte_ANSI		; char is in r8
00000021	42800020		lix		r8,0x20
00000022	D400004A		bsr		putChar_ANSI ; space between characters
00000023	23990001		subi	r9,r9,1
00000024	C7FFFFF6		bnz		nextSDReadChar
00000025	A1504000		pull	PAR
00000026	A1A04000		pull	r10
00000027	A1904000		pull	r9
00000028	A1804000		pull	r8
00000029	A1704000		pull	PC
	
;
; getChar_PS2
; returns character received in r8
;

getChar_PS2:
0000002a	A0405000		push	PAR
0000002b	42500801		lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
0000002c	84805000		lpl		r8			; Read Status into r9
0000002d	2B880001		andi 	r8,r8,1
0000002e	C3FFFFFE		bez 	waitPS2RxStat
getCharFromPS2:
0000002f	42500800		lix 	PAR,0x0800
00000030	84805000		lpl		r8
whilePS2RxStat:
00000031	A1504000		pull	PAR
00000032	A1704000		pull	PC

;
; waitCharPolled_PS2 - Check the polled character interface
; wait for a character
; return when a character is present
; returns character received in r8
;

waitCharPolled_PS2:
00000033	A0405000		push	PAR
00000034	42500803		lix		PAR,0x0803	; PS/2 Status
waitPS2RxStatPolled:
00000035	84805000		lpl		r8			; Read Status into r8
00000036	2B880001		andi 	r8,r8,0x1
00000037	C3FFFFFE		bez 	waitPS2RxStatPolled
getCharFromPS2Polled:
00000038	42500802		lix 	PAR,0x0802
00000039	84805000		lpl		r8
whilePS2RxStatPolled:
0000003a	A1504000		pull	PAR
0000003b	A1704000		pull	PC

;
; checkGetStat_PS2 - Checks the polling status
; Polled interface is active while the keyboard key is pressed
; returns 
;	-1 if there is no character, 
;	character if there is a character
;

checkGetStat_PS2:
0000003c	A0405000		push	PAR
0000003d	42500803		lix		PAR,0x0803	; PS/2 Status
0000003e	84805000		lpl		r8			; Read Status into r8
0000003f	2B880001		andi	r8,r8,0x1
00000040	C3000004		bez		charNotPresent
00000041	42500802		lix		PAR,0x0802
00000042	84805000		lpl		r8
00000043	C0000002		bra		gotCharIn
charNotPresent:
00000044	20802000		add		r8,ZERO,MINUS1
gotCharIn:
00000045	A1504000		pull	PAR
00000046	A1704000		pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putChar_UART:
00000047	A0405000		push	PAR
00000048	A0408000		push	r8
00000049	42501800		lix		PAR,0x1800	; UART Status
waitUartTxStat:
0000004a	84805000		lpl		r8			; Read Status into r8
0000004b	2B880002		andi 	r8,r8,0x2
0000004c	C7000005		bnz 	uartRdy
; Remind user to enable HW handshake
; would be better to add a HW handshake timeout
; Since the USB is so much faster it is unlikely this path 
;	will be exercised. 
; For cards with RS-232 serial this would be a serious concern
; It's more likely that PuTTY needed to be run in HW handshake mode.
handshakeStuck:
0000004d	4280000C		lix		r8,missingHandshake.lower
0000004e	D4000008		bsr		printString_ANSI
0000004f	A1804000		pull	r8
00000050	C0000004		bra		getOut
uartRdy:
00000051	42501801		lix 	PAR,0x1801
00000052	A1804000		pull	r8
00000053	85508000		spl		r8			; echo the character
getOut:
00000054	A1504000		pull	PAR
00000055	A1704000		pull	PC
	
;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
00000056	A0408000		push	r8					; save r8
00000057	A0406000		push	DAR
00000058	21680000		addi	DAR,r8,0x0		; set the start of the string
nextCharANSI:
00000059	68806000		ldbp	r8					; get the character01
0000005a	39380000		cmpi	r8,0x0				; Null terminated string
0000005b	D1000003		beq		donePrANSIStr		; done if null
0000005c	D4000010		bsr		putChar_ANSI	; write out the character
0000005d	C0FFFFFC		bra		nextCharANSI
donePrANSIStr:
0000005e	A1604000		pull	DAR					; restore DAR
0000005f	A1804000		pull	r8					; restore r8
00000060	A1704000		pull	PC					; rts
	
;
; clearScreen_ANSI - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
; No passed value
; Uses r8 (saved during function)
; no return value
;

clearScreen_ANSI:
00000061	A0408000		push	r8				; save r8
00000062	4280001B		lix		r8,0x1b			; ESC
00000063	D4000009		bsr		putChar_ANSI
00000064	4280005B		lix		r8,0x5b			; [
00000065	D4000007		bsr		putChar_ANSI
00000066	42800032		lix		r8,0x32			; 2
00000067	D4000005		bsr		putChar_ANSI
00000068	4280004A		lix		r8,0x4A			; J
00000069	D4000003		bsr		putChar_ANSI
0000006a	A1804000		pull	r8
0000006b	A1704000		pull	PC				; rts

;
; putChar_ANSI - Put a character to the screen
; r8 - Character to put to screen
; r8 - returns character that was sent to screen
;

putChar_ANSI:
0000006c	A0405000		push	PAR
0000006d	A0408000		push	r8
0000006e	42500000		lix		PAR,0x0		; ANSI Screen (UART-style) Status
waitScreenTxStat:
0000006f	84805000		lpl		r8			; Read Status into r9
00000070	2B880002		andi 	r8,r8,0x2
00000071	C3FFFFFE		bez 	waitScreenTxStat
00000072	42500001		lix 	PAR,0x1		; ANSI Screen (UART-style) Data
00000073	A1804000		pull	r8
00000074	81508000		spb		r8			; send character to the screen
00000075	A1504000		pull	PAR
00000076	A1704000		pull	PC
	
; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
00000077	A0408000		push	r8
00000078	A0409000		push	r9
00000079	42503802		lix		PAR,0x3802		; address of the mSec counter
0000007a	84905000		lpl		r9				; read the peripheral counter into r9
0000007b	20898000		add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
0000007c	84905000		lpl		r9				; check the elapsed time counter
0000007d	38389000		cmp		r8,r9
0000007e	CCFFFFFE		blt		loop_delay_mS
0000007f	A1904000		pull	r9
00000080	A1804000		pull	r8
00000081	A1704000		pull	PC

; convLineBuff2DigASCIIToHex7Seg - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

convLineBuff2DigASCIIToHex7Seg:
00000082	A0409000		push	r9
00000083	A0406000		push	DAR
00000084	A0405000		push	PAR
00000085	42900000		lix		r9,0
00000086	20680000		add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
00000087	68806000		ldbp	r8
00000088	D400001C		bsr		asciiCharToHexNibble
00000089	3938DEAD		cmpi	r8,0xDEAD
0000008a	D1000011		beq		badHexVal
0000008b	2B88000F		andi	r8,r8,0xf
0000008c	28998000		or		r9,r9,r8
0000008d	30909000		sl1		r9,r9
0000008e	30909000		sl1		r9,r9
0000008f	30909000		sl1		r9,r9
00000090	30909000		sl1		r9,r9
00000091	60806000		ldb		r8
00000092	D4000012		bsr		asciiCharToHexNibble
00000093	3938DEAD		cmpi	r8,0xDEAD
00000094	D1000007		beq		badHexVal
00000095	2B88000F		andi	r8,r8,0xf
00000096	28998000		or		r9,r9,r8
00000097	42503000		lix		PAR,0x3000		; seven segment display
00000098	85509000		spl		r9
00000099	20890000		add		r8,r9,ZERO
0000009a	C0000006		bra		valOKDone
badHexVal:
0000009b	42800044		lix		r8,syntaxError.lower
0000009c	D40000A0		bsr		newLine_ANSI_UART
0000009d	D4000088		bsr		printString_ANSI_UART
0000009e	D400009E		bsr		newLine_ANSI_UART
0000009f	4280DEAD		lix		r8,0xDEAD
valOKDone:
000000a0	A1504000		pull	PAR
000000a1	A1604000		pull	DAR
000000a2	A1904000		pull	r9
000000a3	A1704000		pull	PC

;
; asciiCharToHexNibble - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

asciiCharToHexNibble:
000000a4	39380066		cmpi	r8,0x66			; past 'f'
000000a5	CC000011		blt		a2h_Error
000000a6	39380030		cmpi	r8,0x30			; below '0'
000000a7	CF00000F		bgt		a2h_Error
000000a8	3938003A		cmpi	r8,0x3A			; '0' - '9'
000000a9	CF000009		bgt		gotDigit
000000aa	39380041		cmpi	r8,0x41			; ':' - '@'
000000ab	CF00000B		bgt		a2h_Error
000000ac	39380047		cmpi	r8,0x47			; 'A' - 'F'
000000ad	CC000007		blt		gotUpperLetter
000000ae	39380061		cmpi	r8,0x61			; 'G' - 'tick'
000000af	CC000007		blt		a2h_Error
; Lower case letter
000000b0	23880057		subi	r8,r8,0x57
000000b1	C000000A		bra		doneConvA2H
; number 0-9
gotDigit:
000000b2	23880030		subi	r8,r8,0x30
000000b3	C0000008		bra		doneConvA2H
; A-F
gotUpperLetter:
000000b4	23880037		subi	r8,r8,0x37
000000b5	C0000006		bra		doneConvA2H
a2h_Error:
000000b6	42800044		lix		r8,syntaxError.lower
000000b7	D4000085		bsr		newLine_ANSI_UART
000000b8	D400006D		bsr		printString_ANSI_UART
000000b9	D4000083		bsr		newLine_ANSI_UART
000000ba	4280DEAD		lix		r8,0xDEAD
doneConvA2H:
000000bb	A1704000		pull	PC

;
; printLong_ANSI_UART
; r8 contains the long value to print
;

printLong_ANSI_UART:
000000bc	A0408000		push	r8
000000bd	A0409000		push	r9
000000be	A0408000		push	r8				; temporarily save r8
000000bf	42800030		lix		r8,0x30			; print 0x
000000c0	D400004C		bsr		putChar_ANSI_UART
000000c1	42800078		lix		r8,0x78
000000c2	D400004A		bsr		putChar_ANSI_UART
000000c3	A1804000		pull	r8				; restore r8
000000c4	42900008		lix		r9,8			; loop counter
doNextprintLong_ANSI_UART:
000000c5	34808000		rol1	r8,r8
000000c6	34808000		rol1	r8,r8
000000c7	34808000		rol1	r8,r8
000000c8	34808000		rol1	r8,r8
000000c9	D4000046		bsr		printHexVal_ANSI_UART
000000ca	23990001		subi	r9,r9,1
000000cb	C7FFFFFA		bnz		doNextprintLong_ANSI_UART
000000cc	A1904000		pull	r9
000000cd	A1804000		pull	r8
000000ce	A1704000		pull	PC

;
; printShort_ANSI_UART
; r8 contains the short value to print
;

printShort_ANSI_UART:
000000cf	A0408000		push	r8
000000d0	A0409000		push	r9
000000d1	A0408000		push	r8				; temporarily save r8
000000d2	42800030		lix		r8,0x30			; print 0x
000000d3	D4000039		bsr		putChar_ANSI_UART
000000d4	42800078		lix		r8,0x78
000000d5	D4000037		bsr		putChar_ANSI_UART
000000d6	A1804000		pull	r8				; restore r8
000000d7	42900004		lix		r9,4			; loop counter
000000d8	31808000		sl8		r8,r8
000000d9	31808000		sl8		r8,r8
doNextprintShort_ANSI_UART:
000000da	34808000		rol1	r8,r8
000000db	34808000		rol1	r8,r8
000000dc	34808000		rol1	r8,r8
000000dd	34808000		rol1	r8,r8
000000de	D4000031		bsr		printHexVal_ANSI_UART
000000df	23990001		subi	r9,r9,1
000000e0	C7FFFFFA		bnz		doNextprintShort_ANSI_UART
000000e1	A1904000		pull	r9
000000e2	A1804000		pull	r8
000000e3	A1704000		pull	PC

;
; printByte_ANSI_UART
; r8 contains the char value to print
;

printByte_ANSI_UART:
000000e4	A0408000		push	r8
000000e5	A0409000		push	r9
000000e6	A0408000		push	r8				; temporarily save r8
000000e7	42800030		lix		r8,0x30			; print 0x
000000e8	D4000024		bsr		putChar_ANSI_UART
000000e9	42800078		lix		r8,0x78
000000ea	D4000022		bsr		putChar_ANSI_UART
000000eb	A1804000		pull	r8				; restore r8
000000ec	42900002		lix		r9,2			; loop counter
000000ed	31808000		sl8		r8,r8
000000ee	31808000		sl8		r8,r8
000000ef	31808000		sl8		r8,r8
doNextprintByte_ANSI_UART:
000000f0	34808000		rol1	r8,r8
000000f1	34808000		rol1	r8,r8
000000f2	34808000		rol1	r8,r8
000000f3	34808000		rol1	r8,r8
000000f4	D400001B		bsr		printHexVal_ANSI_UART
000000f5	23990001		subi	r9,r9,1
000000f6	C7FFFFFA		bnz		doNextprintByte_ANSI_UART
000000f7	A1904000		pull	r9
000000f8	A1804000		pull	r8
000000f9	A1704000		pull	PC
	
;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
000000fa	A0408000		push	r8
000000fb	A0409000		push	r9
000000fc	A0408000		push	r8				; temporarily save r8
000000fd	A1804000		pull	r8				; restore r8
000000fe	42900002		lix		r9,2			; loop counter
000000ff	31808000		sl8		r8,r8
00000100	31808000		sl8		r8,r8
00000101	31808000		sl8		r8,r8
doNextprintByte_ANSI:
00000102	34808000		rol1	r8,r8
00000103	34808000		rol1	r8,r8
00000104	34808000		rol1	r8,r8
00000105	34808000		rol1	r8,r8
00000106	D4000014		bsr		printHexVal_ANSI
00000107	23990001		subi	r9,r9,1
00000108	C7FFFFFA		bnz		doNextprintByte_ANSI
00000109	A1904000		pull	r9
0000010a	A1804000		pull	r8
0000010b	A1704000		pull	PC
	
; putChar_ANSI_UART
; write out a character to both 
;	the ANSI screen and the UART

putChar_ANSI_UART:
0000010c	D4FFFF60		bsr		putChar_ANSI
0000010d	D4FFFF3A		bsr		putChar_UART
0000010e	A1704000		pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI_UART:
0000010f	A0408000		push	r8
00000110	2B88000F		andi	r8,r8,0xf
00000111	39380009		cmpi	r8,9
00000112	CC000004		blt		printHexLetter
00000113	21880030		addi	r8,r8,0x30
00000114	D4FFFFF8		bsr		putChar_ANSI_UART
00000115	C0000003		bra		donePrintHexVal
printHexLetter:
00000116	21880037		addi	r8,r8,0x37		; 'A' - 10
00000117	D4FFFFF5		bsr		putChar_ANSI_UART
donePrintHexVal:
00000118	A1804000		pull	r8
00000119	A1704000		pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI:
0000011a	A0408000		push	r8
0000011b	2B88000F		andi	r8,r8,0xf
0000011c	39380009		cmpi	r8,9
0000011d	CC000004		blt		printHexLetterANSI
0000011e	21880030		addi	r8,r8,0x30
0000011f	D4FFFF4D		bsr		putChar_ANSI
00000120	C0000003		bra		donePrintHexValANSI
printHexLetterANSI:
00000121	21880037		addi	r8,r8,0x37		; 'A' - 10
00000122	D4FFFF4A		bsr		putChar_ANSI
donePrintHexValANSI:
00000123	A1804000		pull	r8
00000124	A1704000		pull	PC

;
; printString_ANSI_UART - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI_UART:
00000125	A0408000		push	r8					; save r8
00000126	A0406000		push	DAR
00000127	21680000		addi	DAR,r8,0			; set the start of the string
nextChar:
00000128	68806000		ldbp	r8					; get the character01
00000129	39380000		cmpi	r8,0x0				; Null terminated string
0000012a	D1000003		beq		donePrStr			; done if null
0000012b	D4FFFFE1		bsr		putChar_ANSI_UART	; write out the character
0000012c	C0FFFFFC		bra		nextChar
donePrStr:
0000012d	A1604000		pull	DAR					; restore DAR
0000012e	A1804000		pull	r8					; restore r8
0000012f	A1704000		pull	PC					; rts
	
;
; printLinebuffer_ANSI_UART - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLinebuffer_ANSI_UART:
00000130	A0408000		push	r8					; save r8
00000131	A0406000		push	DAR
00000132	21680000		addi	DAR,r8,0x0			; set the start of the string
nextChar2:
00000133	68806000		ldbp	r8					; get the character
00000134	39380000		cmpi	r8,0x0				; Null terminated string
00000135	D1000003		beq		donePrStr2			; done if null
00000136	D4FFFF20		bsr		printString_ANSI	; write out the character
00000137	C0FFFFFC		bra		nextChar2
donePrStr2:
00000138	D4000004		bsr		newLine_ANSI_UART
00000139	A1604000		pull	DAR					; restore DAR
0000013a	A1804000		pull	r8					; restore r8
0000013b	A1704000		pull	PC					; rts
	
;
; newLine_ANSI_UART - Print out a newLine_ANSI_UART (CR-LF)
;

newLine_ANSI_UART:
0000013c	A0408000		push	r8
0000013d	4280000A		lix		r8,0x0A				; Line Feed
0000013e	D4FFFFCE		bsr		putChar_ANSI_UART	; Put the character to the screen
0000013f	4280000D		lix		r8,0x0D				; Carriage Return
00000140	D4FFFFCC		bsr		putChar_ANSI_UART		; Echo character back to the UART
00000141	A1804000		pull	r8
00000142	A1704000		pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
00000143	A0408000		push	r8
00000144	4280000A		lix		r8,0x0A				; Line Feed
00000145	D4FFFF27		bsr		putChar_ANSI	; Put the character to the screen
00000146	4280000D		lix		r8,0x0D				; Carriage Return
00000147	D4FFFF25		bsr		putChar_ANSI	; Echo character back to the UART
00000148	A1804000		pull	r8
00000149	A1704000		pull	PC

;
; clearScreen_ANSI_UART - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen_ANSI_UART:
0000014a	A0408000		push	r8				; save r8
0000014b	4280001B		lix		r8,0x1b			; ESC
0000014c	D4FFFFC0		bsr		putChar_ANSI_UART
0000014d	4280005B		lix		r8,0x5b			; [
0000014e	D4FFFFBE		bsr		putChar_ANSI_UART
0000014f	42800032		lix		r8,0x32			; 2
00000150	D4FFFFBC		bsr		putChar_ANSI_UART
00000151	4280004A		lix		r8,0x4A			; J
00000152	D4FFFFBA		bsr		putChar_ANSI_UART
00000153	A1804000		pull	r8
00000154	A1704000		pull	PC				; rts

	