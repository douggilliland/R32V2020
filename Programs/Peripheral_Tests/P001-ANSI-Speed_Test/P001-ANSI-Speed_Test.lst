;
; P001-ANSI-Speed_Test - Test the speed of the ANSI display hardware
;
; Tests include
;	1 - Character write speed (no scroll)
;	2 - Screen clear speed
;	3 - Screen scroll speed
;

00000000	prompt:			.string "ANSI VDU Speed Tests"
; lineBuff is 80 characters long
00000001	lineBuff:		.string "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
00000002	syntaxError:	.string "Syntax error"
00000003	runningString:	.string "Running..."
00000004	hitAnyKey:		.string "Hit any key to exit..."
00000005	serialOverflow:	.string "Serial port overflow"
00000006	testMetric:		.string "Ran test 1024 times in (uSecs) : "
00000007	menuItem_01:	.string "01 - Character write speed"
00000008	menuItem_02:	.string "02 - Screen clear speed"
00000009	menuItem_03:	.string "03 - Screen scroll speed"

;
; Read a line from the UART and parse the line
;

main:
00000000	D40000A7	bsr		clearScreen_ANSI
00000001	42800000	lix		r8,prompt.lower
00000002	D4000105	bsr		printLinebuffer_ANSI_UART
00000003	D4000004	bsr		printMenu
00000004	D4000269	bsr		readToLineBuffer
00000005	D400000B	bsr		callTests
00000006	C0FFFFFA	bra		main

;
; printMenu - Print the menu
;

printMenu:
00000007	A0408000	push	r8
00000008	428000DC	lix		r8,menuItem_01.lower
00000009	D40000FE	bsr		printLinebuffer_ANSI_UART
0000000a	428000F8	lix		r8,menuItem_02.lower
0000000b	D40000FC	bsr		printLinebuffer_ANSI_UART
0000000c	42800110	lix		r8,menuItem_03.lower
0000000d	D40000FA	bsr		printLinebuffer_ANSI_UART
0000000e	A1804000	pull	r8
0000000f	A1704000	pull	PC

;
; callTests -
; line is in lineBuff
;	1 - Character write speed
;	2 - Screen clear speed
;	3 - Screen scroll speed
; Uses r8 for the command
;

callTests:
00000010	A0408000	push	r8
00000011	42800018	lix		r8,lineBuff.lower
00000012	D400012E	bsr		hexToSevenSeg_ANSI_UART
; testCharWriteSpeed
00000013	39380001	cmpi	r8,0x01
00000014	D2000003	bne		skipTo2
00000015	D4000010	bsr		testCharWriteSpeed
00000016	C000000D	bra		doneTests
; testScreenClearSpeed
skipTo2:
00000017	39380002	cmpi	r8,0x02
00000018	D2000003	bne		skipTo3
00000019	D4000034	bsr		testScreenClearSpeed
0000001a	C0000009	bra		doneTests
; testScreenScrollSpeed
skipTo3:
0000001b	39380003	cmpi	r8,0x03
0000001c	D2000003	bne		skipToEnd
0000001d	D4000051	bsr		testScreenScrollSpeed
0000001e	C0000005	bra		doneTests
; testScreenScrollSpeed
skipToEnd:
0000001f	A0408000	push	r8
00000020	4280006C	lix		r8,syntaxError.lower
00000021	D40000DB	bsr		printString_ANSI_UART
00000022	A1804000	pull	r8
doneTests:
00000023	A1804000	pull	r8
00000024	A1704000	pull	PC

;
; testCharWriteSpeed - Test Char Write Speed
; Use microsecond counter - 0x3801 is microsecond counter
; Measured 0x31F = 799 uS for 1024 chars or 0.78 uS/char or 1.2M chars/sec
;

testCharWriteSpeed:
00000025	A0405000	push	PAR
00000026	A0408000	push	r8
00000027	A0409000	push	r9
00000028	A040A000	push	r10
00000029	D400007E	bsr		clearScreen_ANSI
0000002a	4280000A	lix		r8,10		; Delay for 10 mS to give the screen time to clear
0000002b	D4000201	bsr		delay_mS
0000002c	42800031	lix		r8,0x31		; char to print is '1'
0000002d	42A00400	lix		r10,1024	; print 1024 characters
0000002e	42503801	lix		PAR,0x3801	; microsecond counter
0000002f	84905000	lpl		r9			; read the counter
anotherCharTest:
00000030	42500000	lix		PAR,0x0		; ANSI Screen Status (UART style)
waitScreenTxStat3:
00000031	84B05000	lpl		r11			; Read Status into r9
00000032	2BBB0002	andi	r11,r11,0x2
00000033	C3FFFFFE	bez 	waitScreenTxStat3
00000034	42500001	lix 	PAR,0x1		; ANSI Screen Data (UART style)
00000035	85508000	spl		r8			; echo the character
00000036	23AA0001	subi	r10,r10,1
00000037	C7FFFFF9	bnz		anotherCharTest
00000038	42503801	lix		PAR,0x3801	; microsecond counter
00000039	84805000	lpl		r8			; read the counter
0000003a	22898000	sub		r8,r9,r8	; How many microseconds to clear screen?
0000003b	D4000213	bsr		wr7Seg8Dig	; put number of microseconds out to 7 seg display
0000003c	D40000D7	bsr		newLine_ANSI_UART
0000003d	A0408000	push	r8
0000003e	428000B8	lix		r8,testMetric.lower
0000003f	D40000BD	bsr		printString_ANSI_UART
00000040	A1804000	pull	r8
00000041	D4000159	bsr		printLong_ANSI_UART
00000042	D40000D1	bsr		newLine_ANSI_UART
00000043	42800088	lix		r8,hitAnyKey.lower
00000044	D40000C3	bsr		printLinebuffer_ANSI_UART
reload001:
00000045	D4000186	bsr		checkForCharAndDiscard
00000046	39380000	cmpi	r8,0
00000047	D1FFFFFE	beq		reload001
00000048	A1A04000	pull	r10
00000049	A1904000	pull	r9
0000004a	A1804000	pull	r8
0000004b	A1504000	pull	PAR
0000004c	A1704000	pull	PC

;
; testScreenClearSpeed - Test Screen Clear Speed
; 1024 screen clears take 0x190CC = 102,604 uS
;	100.2 uS to clear the screen
;

testScreenClearSpeed:
0000004d	A0405000	push	PAR
0000004e	A0408000	push	r8
0000004f	A0409000	push	r9
00000050	A040A000	push	r10
00000051	4280000A	lix		r8,10		; Delay for 10 mS to give the screen time to clear
00000052	D40001DA	bsr		delay_mS
00000053	42A00400	lix		r10,1024	; clear screen 1024 times
00000054	42503801	lix		PAR,0x3801	; microsecond counter
00000055	84905000	lpl		r9			; read the counter
clearAgain:
00000056	D4000051	bsr		clearScreen_ANSI
00000057	23AA0001	subi	r10,r10,1
00000058	C7FFFFFE	bnz		clearAgain
00000059	42503801	lix		PAR,0x3801	; microsecond counter
0000005a	84805000	lpl		r8			; read the counter
0000005b	22898000	sub		r8,r9,r8	; How many microseconds to clear screen?
0000005c	D40001F2	bsr		wr7Seg8Dig	; put number of microseconds out to 7 seg display
0000005d	D40000B6	bsr		newLine_ANSI_UART
0000005e	A0408000	push	r8
0000005f	428000B8	lix		r8,testMetric.lower
00000060	D400009C	bsr		printString_ANSI_UART
00000061	A1804000	pull	r8
00000062	D4000138	bsr		printLong_ANSI_UART
00000063	D40000B0	bsr		newLine_ANSI_UART
00000064	42800088	lix		r8,hitAnyKey.lower
00000065	D4000097	bsr		printString_ANSI_UART
reload002:
00000066	D4000165	bsr		checkForCharAndDiscard
00000067	39380000	cmpi	r8,0
00000068	D1FFFFFE	beq		reload002
00000069	A1A04000	pull	r10
0000006a	A1904000	pull	r9
0000006b	A1804000	pull	r8
0000006c	A1504000	pull	PAR
0000006d	A1704000	pull	PC

;
; testScreenScrollSpeed - Test Screen Scroll Speed
; 1024 lines in 0x0FC7 uSecs = 4,039 uS
;	 3.94 uS to scroll screen
;

testScreenScrollSpeed:
0000006e	A0405000	push	PAR
0000006f	A0408000	push	r8
00000070	A0409000	push	r9
00000071	A040A000	push	r10
00000072	A040B000	push	r11
00000073	4280000A	lix		r8,0x0A				; Line Feed
00000074	42A0001A	lix		r10,26				; prescroll by 26 lines to get to the bottom of the screen
scrollAgain:
00000075	D4000027	bsr		putChar_ANSI
00000076	23AA0001	subi	r10,r10,1
00000077	C7FFFFFE	bnz		scrollAgain
00000078	428001F4	lix		r8,500		; Delay for 500 mS to give the screen time to scroll
00000079	D40001B3	bsr		delay_mS
0000007a	4280000A	lix		r8,0x0A				; Line Feed
0000007b	42A00400	lix		r10,1024
0000007c	42503801	lix		PAR,0x3801	; microsecond counter
0000007d	84905000	lpl		r9			; read the counter
anotherScroll:
0000007e	42500000	lix		PAR,0x0		; ANSI Screen Status (UART style)
waitScreenTxStat2:
0000007f	84B05000	lpl		r11			; Read Status into r9
00000080	2BBB0002	andi	r11,r11,0x2
00000081	C3FFFFFE	bez 	waitScreenTxStat2
00000082	42500001	lix 	PAR,0x1		; ANSI Screen Data (UART style)
00000083	85508000	spl		r8			; echo the character
00000084	23AA0001	subi	r10,r10,1
00000085	C7FFFFF9	bnz		anotherScroll
00000086	42503801	lix		PAR,0x3801	; microsecond counter
00000087	84805000	lpl		r8			; read the counter
00000088	22898000	sub		r8,r9,r8	; How many microseconds to clear screen?
00000089	D40001C5	bsr		wr7Seg8Dig	; put number of microseconds out to 7 seg display
0000008a	D4000089	bsr		newLine_ANSI_UART
0000008b	A0408000	push	r8
0000008c	428000B8	lix		r8,testMetric.lower
0000008d	D400006F	bsr		printString_ANSI_UART
0000008e	A1804000	pull	r8
0000008f	D400010B	bsr		printLong_ANSI_UART
00000090	D4000083	bsr		newLine_ANSI_UART
00000091	42800088	lix		r8,hitAnyKey.lower
00000092	D400006A	bsr		printString_ANSI_UART
reload003:
00000093	D4000138	bsr		checkForCharAndDiscard
00000094	39380000	cmpi	r8,0
00000095	D1FFFFFE	beq		reload003
00000096	A1B04000	pull	r11
00000097	A1A04000	pull	r10
00000098	A1904000	pull	r9
00000099	A1804000	pull	r8
0000009a	A1504000	pull	PAR
0000009b	A1704000	pull	PC

;--------------------------------------------------------------------
; ANSIScreen.asm

;
; putChar_ANSI - Put a character to the screen
; Character to put to screen is in r8
;

putChar_ANSI:
0000009c	A0409000	push	r9
0000009d	A0405000	push	PAR
0000009e	42500000	lix		PAR,0x0		; UART Status
waitScreenTxStat:
0000009f	84905000	lpl		r9			; Read Status into r9
000000a0	2B990002	andi	r9,r9,0x2
000000a1	C3FFFFFE	bez 	waitScreenTxStat
000000a2	42500001	lix 	PAR,0x1
000000a3	85508000	spl		r8			; echo the character
000000a4	A1504000	pull	PAR
000000a5	A1904000	pull	r9
000000a6	A1704000	pull	PC

;
; clearScreen_ANSI - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
; No passed value
; Uses r8 (saved during function)
; no return value
;

clearScreen_ANSI:
000000a7	A0408000	push	r8				; save r8
000000a8	4280001B	lix		r8,0x1b			; ESC
000000a9	D4FFFFF3	bsr		putChar_ANSI
000000aa	4280005B	lix		r8,0x5b			; [
000000ab	D4FFFFF1	bsr		putChar_ANSI
000000ac	42800032	lix		r8,0x32			; 2
000000ad	D4FFFFEF	bsr		putChar_ANSI
000000ae	4280004A	lix		r8,0x4A			; J
000000af	D4FFFFED	bsr		putChar_ANSI
000000b0	A1804000	pull	r8
000000b1	A1704000	pull	PC				; rts

;
; printANSICode - Send the ANSI Escape Sequence
; printCode_ANSI - Send the ANSI Escape Sequence
; r8 - points to the string
; This routine supplies the ESC
;

printANSICode:
printCode_ANSI:
000000b2	A0408000	push	r8
000000b3	A0408000	push	r8
000000b4	4280001B	lix		r8,0x1b			; ESC
000000b5	D4FFFFE7	bsr		putChar_ANSI
000000b6	A1804000	pull	r8
000000b7	D400000A	bsr		printString_ANSI
000000b8	A1804000	pull	r8
000000b9	A1704000	pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
000000ba	A0408000	push	r8
000000bb	4280000A	lix		r8,0x0A				; Line Feed
000000bc	D4FFFFE0	bsr		putChar_ANSI	; Put the character to the screen
000000bd	4280000D	lix		r8,0x0D				; Carriage Return
000000be	D4FFFFDE	bsr		putChar_ANSI	; Echo character back to the UART
000000bf	A1804000	pull	r8
000000c0	A1704000	pull	PC

;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
000000c1	A0408000	push	r8					; save r8
000000c2	A0406000	push	DAR
000000c3	20680000	add		DAR,r8,ZERO			; set the start of the string
nextCharANSI:
000000c4	68806000	ldbp	r8					; get the character01
000000c5	39380000	cmpi	r8,0x0				; Null terminated string
000000c6	D1000003	beq		donePrANSIStr		; done if null
000000c7	D4FFFFD5	bsr		putChar_ANSI	; write out the character
000000c8	C0FFFFFC	bra		nextCharANSI
donePrANSIStr:
000000c9	A1604000	pull	DAR					; restore DAR
000000ca	A1804000	pull	r8					; restore r8
000000cb	A1704000	pull	PC					; rts

;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
000000cc	A0408000	push	r8
000000cd	A0409000	push	r9
000000ce	A0408000	push	r8				; temporarily save r8
000000cf	A1804000	pull	r8				; restore r8
000000d0	42900002	lix		r9,2			; loop counter
000000d1	31808000	sl8		r8,r8
000000d2	31808000	sl8		r8,r8
000000d3	31808000	sl8		r8,r8
doNextprintByte_ANSI:
000000d4	34808000	rol1	r8,r8
000000d5	34808000	rol1	r8,r8
000000d6	34808000	rol1	r8,r8
000000d7	34808000	rol1	r8,r8
000000d8	D4000006	bsr		printHexVal_ANSI
000000d9	23990001	subi	r9,r9,1
000000da	C7FFFFFA	bnz		doNextprintByte_ANSI
000000db	A1904000	pull	r9
000000dc	A1804000	pull	r8
000000dd	A1704000	pull	PC

;
; printHexValANSI
;

printHexVal_ANSI:
000000de	A0408000	push	r8
000000df	2B88000F	andi	r8,r8,0xf
000000e0	39380009	cmpi	r8,9
000000e1	CC000004	blt		printHexLetterANSI
000000e2	21880030	addi	r8,r8,0x30
000000e3	D4FFFFB9	bsr		putChar_ANSI
000000e4	C0000003	bra		donePrintHexValANSI
printHexLetterANSI:
000000e5	21880037	addi	r8,r8,0x37		; 'A' - 10
000000e6	D4FFFFB6	bsr		putChar_ANSI
donePrintHexValANSI:
000000e7	A1804000	pull	r8
000000e8	A1704000	pull	PC

;
; printLong_ANSI
; r8 contains the long value to print
;

printLong_ANSI:
000000e9	A0408000	push	r8
000000ea	A0409000	push	r9
000000eb	A0408000	push	r8				; temporarily save r8
000000ec	42800030	lix		r8,0x30			; print 0x
000000ed	D4FFFFAF	bsr		putChar_ANSI
000000ee	42800078	lix		r8,0x78
000000ef	D4FFFFAD	bsr		putChar_ANSI
000000f0	A1804000	pull	r8				; restore r8
000000f1	42900008	lix		r9,8			; loop counter
doNextprintLong_ANSI:
000000f2	34808000	rol1	r8,r8
000000f3	34808000	rol1	r8,r8
000000f4	34808000	rol1	r8,r8
000000f5	34808000	rol1	r8,r8
000000f6	D4FFFFE8	bsr		printHexVal_ANSI
000000f7	23990001	subi	r9,r9,1
000000f8	C7FFFFFA	bnz		doNextprintLong_ANSI
000000f9	A1904000	pull	r9
000000fa	A1804000	pull	r8
000000fb	A1704000	pull	PC
;--------------------------------------------------------------------
; ANSI_UART_io.asm

;
; ANSI_UART_io.asm -
;

;
; printString_ANSI_UART - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI_UART:
000000fc	A0408000	push	r8					; save r8
000000fd	A0406000	push	DAR
000000fe	20680000	add		DAR,r8,ZERO			; set the start of the string
nextChar:
000000ff	68806000	ldbp	r8					; get the character01
00000100	39380000	cmpi	r8,0x0				; Null terminated string
00000101	D1000003	beq		donePrStr			; done if null
00000102	D4000023	bsr		write_ANSI_UART	; write out the character
00000103	C0FFFFFC	bra		nextChar
donePrStr:
00000104	A1604000	pull	DAR					; restore DAR
00000105	A1804000	pull	r8					; restore r8
00000106	A1704000	pull	PC					; rts

;
; printLinebuffer_ANSI_UART - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLinebuffer_ANSI_UART:
00000107	A0408000	push	r8					; save r8
00000108	A0406000	push	DAR
00000109	21680000	addi	DAR,r8,0x0			; set the start of the string
nextChar2:
0000010a	68806000	ldbp	r8					; get the character
0000010b	39380000	cmpi	r8,0x0				; Null terminated string
0000010c	D1000003	beq		donePrStr2			; done if null
0000010d	D4000018	bsr		write_ANSI_UART	; write out the character
0000010e	C0FFFFFC	bra		nextChar2
donePrStr2:
0000010f	D4000004	bsr		newLine_ANSI_UART
00000110	A1604000	pull	DAR					; restore DAR
00000111	A1804000	pull	r8					; restore r8
00000112	A1704000	pull	PC					; rts

;
; newLine_ANSI_UART - Print out a newLine_ANSI_UART (CR-LF)
;

newLine_ANSI_UART:
00000113	A0408000	push	r8
00000114	4280000A	lix		r8,0x0A				; Line Feed
00000115	D4000010	bsr		write_ANSI_UART	; Put the character to the screen
00000116	4280000D	lix		r8,0x0D				; Carriage Return
00000117	D400000E	bsr		write_ANSI_UART		; Echo character back to the UART
00000118	A1804000	pull	r8
00000119	A1704000	pull	PC

;
; clearScreen_ANSI_UART - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen_ANSI_UART:
0000011a	A0408000	push	r8				; save r8
0000011b	4280001B	lix		r8,0x1b			; ESC
0000011c	D4000009	bsr		write_ANSI_UART
0000011d	4280005B	lix		r8,0x5b			; [
0000011e	D4000007	bsr		write_ANSI_UART
0000011f	42800032	lix		r8,0x32			; 2
00000120	D4000005	bsr		write_ANSI_UART
00000121	4280004A	lix		r8,0x4A			; J
00000122	D4000003	bsr		write_ANSI_UART
00000123	A1804000	pull	r8
00000124	A1704000	pull	PC				; rts

; write_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

write_ANSI_UART:
00000125	D4FFFF77	bsr		putChar_ANSI
00000126	D40000D6	bsr		putChar_UART
00000127	A1704000	pull	PC

;
; asciiToHex_ANSI_UART - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

asciiToHex_ANSI_UART:
00000128	39380066	cmpi	r8,0x66			; past 'f'
00000129	CC000011	blt		a2h_Error
0000012a	39380030	cmpi	r8,0x30			; below '0'
0000012b	CF00000F	bgt		a2h_Error
0000012c	3938003A	cmpi	r8,0x3A			; '0' - '9'
0000012d	CF000009	bgt		gotDigit
0000012e	39380041	cmpi	r8,0x41			; ':' - '@'
0000012f	CF00000B	bgt		a2h_Error
00000130	39380047	cmpi	r8,0x47			; 'A' - 'F'
00000131	CC000007	blt		gotUpperLetter
00000132	39380061	cmpi	r8,0x61			; 'G' - 'tick'
00000133	CC000007	blt		a2h_Error
; Lower case letter
00000134	23880057	subi	r8,r8,0x57
00000135	C000000A	bra		doneConvA2H
; number 0-9
gotDigit:
00000136	23880030	subi	r8,r8,0x30
00000137	C0000008	bra		doneConvA2H
; A-F
gotUpperLetter:
00000138	23880037	subi	r8,r8,0x37
00000139	C0000006	bra		doneConvA2H
a2h_Error:
0000013a	4280006C	lix		r8,syntaxError.lower
0000013b	D4FFFFD8	bsr		newLine_ANSI_UART
0000013c	D4FFFFC0	bsr		printString_ANSI_UART
0000013d	D4FFFFD6	bsr		newLine_ANSI_UART
0000013e	4280DEAD	lix		r8,0xDEAD
doneConvA2H:
0000013f	A1704000	pull	PC

; hexToSevenSeg_ANSI_UART - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg_ANSI_UART:
00000140	A0409000	push	r9
00000141	A0406000	push	DAR
00000142	A0405000	push	PAR
00000143	42900000	lix		r9,0
00000144	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
00000145	68806000	ldbp	r8
00000146	D4FFFFE2	bsr		asciiToHex_ANSI_UART
00000147	3938DEAD	cmpi	r8,0xDEAD
00000148	D1000011	beq		badHexVal
00000149	2B88000F	andi	r8,r8,0xf
0000014a	28998000	or		r9,r9,r8
0000014b	30909000	sl1		r9,r9
0000014c	30909000	sl1		r9,r9
0000014d	30909000	sl1		r9,r9
0000014e	30909000	sl1		r9,r9
0000014f	60806000	ldb		r8
00000150	D4FFFFD8	bsr		asciiToHex_ANSI_UART
00000151	3938DEAD	cmpi	r8,0xDEAD
00000152	D1000007	beq		badHexVal
00000153	2B88000F	andi	r8,r8,0xf
00000154	28998000	or		r9,r9,r8
00000155	42503000	lix		PAR,0x3000		; seven segment display
00000156	85509000	spl		r9
00000157	20890000	add		r8,r9,ZERO
00000158	C0000006	bra		valOKDone
badHexVal:
00000159	4280006C	lix		r8,syntaxError.lower
0000015a	D4FFFFB9	bsr		newLine_ANSI_UART
0000015b	D4FFFFA1	bsr		printString_ANSI_UART
0000015c	D4FFFFB7	bsr		newLine_ANSI_UART
0000015d	4280DEAD	lix		r8,0xDEAD
valOKDone:
0000015e	A1504000	pull	PAR
0000015f	A1604000	pull	DAR
00000160	A1904000	pull	r9
00000161	A1704000	pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI_UART:
00000162	A0408000	push	r8
00000163	2B88000F	andi	r8,r8,0xf
00000164	39380009	cmpi	r8,9
00000165	CC000004	blt		printHexLetterANSI_UART
00000166	21880030	addi	r8,r8,0x30
00000167	D4FFFFBE	bsr		write_ANSI_UART
00000168	C0000003	bra		doneprintHexValANSI_UART
printHexLetterANSI_UART:
00000169	21880037	addi	r8,r8,0x37		; 'A' - 10
0000016a	D4FFFFBB	bsr		write_ANSI_UART
doneprintHexValANSI_UART:
0000016b	A1804000	pull	r8
0000016c	A1704000	pull	PC

;
; printByte_ANSI_UART
; r8 contains the short value to print
;

printByte_ANSI_UART:
0000016d	A0408000	push	r8
0000016e	A0409000	push	r9
0000016f	A0408000	push	r8				; temporarily save r8
00000170	42800030	lix		r8,0x30			; print 0x
00000171	D400003E	bsr		putChar_ANSI_UART
00000172	42800078	lix		r8,0x78
00000173	D400003C	bsr		putChar_ANSI_UART
00000174	A1804000	pull	r8				; restore r8
00000175	42900002	lix		r9,2			; loop counter
00000176	31808000	sl8		r8,r8
00000177	31808000	sl8		r8,r8
00000178	31808000	sl8		r8,r8
doNextprintByte_ANSI_UART:
00000179	34808000	rol1	r8,r8
0000017a	34808000	rol1	r8,r8
0000017b	34808000	rol1	r8,r8
0000017c	34808000	rol1	r8,r8
0000017d	D4FFFFE5	bsr		printHexVal_ANSI_UART
0000017e	23990001	subi	r9,r9,1
0000017f	C7FFFFFA	bnz		doNextprintByte_ANSI_UART
00000180	A1904000	pull	r9
00000181	A1804000	pull	r8
00000182	A1704000	pull	PC

;
; printShort_ANSI_UART
; r8 contains the short value to print
;

printShort_ANSI_UART:
00000183	A0408000	push	r8
00000184	A0409000	push	r9
00000185	A040A000	push	r10
00000186	A0408000	push	r8				; temporarily save r8
00000187	42800030	lix		r8,0x30
00000188	D4FFFF9D	bsr		write_ANSI_UART
00000189	42800078	lix		r8,0x78
0000018a	D4FFFF9B	bsr		write_ANSI_UART
0000018b	A1804000	pull	r8				; restore r8
0000018c	42900004	lix		r9,4			; loop counter
0000018d	31808000	sl8		r8,r8
0000018e	31808000	sl8		r8,r8
doNextprintShortANSI_UART:
0000018f	34808000	rol1	r8,r8
00000190	34808000	rol1	r8,r8
00000191	34808000	rol1	r8,r8
00000192	34808000	rol1	r8,r8
00000193	D4FFFFCF	bsr		printHexVal_ANSI_UART
00000194	23990001	subi	r9,r9,1
00000195	C7FFFFFA	bnz		doNextprintShortANSI_UART
00000196	A1A04000	pull	r10
00000197	A1904000	pull	r9
00000198	A1804000	pull	r8
00000199	A1704000	pull	PC

;
; printLong_ANSI_UART
; r8 contains the long value to print
;

printLong_ANSI_UART:
0000019a	A0408000	push	r8
0000019b	A0409000	push	r9
0000019c	A040A000	push	r10
0000019d	A0408000	push	r8				; temporarily save r8
0000019e	42800030	lix		r8,0x30
0000019f	D4FFFF86	bsr		write_ANSI_UART
000001a0	42800078	lix		r8,0x78
000001a1	D4FFFF84	bsr		write_ANSI_UART
000001a2	A1804000	pull	r8				; restore r8
000001a3	42900008	lix		r9,8			; loop counter
doNextprintLongANSI_UART:
000001a4	34808000	rol1	r8,r8
000001a5	34808000	rol1	r8,r8
000001a6	34808000	rol1	r8,r8
000001a7	34808000	rol1	r8,r8
000001a8	D4FFFFBA	bsr		printHexVal_ANSI_UART
000001a9	23990001	subi	r9,r9,1
000001aa	C7FFFFFA	bnz		doNextprintLongANSI_UART
000001ab	A1A04000	pull	r10
000001ac	A1904000	pull	r9
000001ad	A1804000	pull	r8
000001ae	A1704000	pull	PC

; putChar_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

putChar_ANSI_UART:
000001af	D4FFFEED	bsr		putChar_ANSI
000001b0	D400004C	bsr		putChar_UART
000001b1	A1704000	pull	PC
;--------------------------------------------------------------------
; ps2.asm - Functions to read the PS/2 keyboard
;
; Address	Function
; x0800 	Latched Keyboard Data
; x0801 	Latched Keyboard Status
; x0802 	Polled Keyboard Data
; x0803 	Polled Keyboard Status
;
; getChar_PS2
; returns character received in r8
;

getChar_PS2:
000001b2	A0405000	push	PAR
000001b3	42500801	lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
000001b4	84805000	lpl		r8			; Read Status into r9
000001b5	2B880001	andi 	r8,r8,1
000001b6	C3FFFFFE	bez 	waitPS2RxStat
getCharFromPS2:
000001b7	42500800	lix 	PAR,0x0800
000001b8	84805000	lpl		r8
whilePS2RxStat:
000001b9	A1504000	pull	PAR
000001ba	A1704000	pull	PC

; waitReadPS2_UART
; wait for character from either
;	the PS/2 keyboard or the UART serial
; r8 = read character

waitReadPS2_UART:
000001bb	A0405000	push	PAR
checkCharFromPS2:
000001bc	42500801	lix		PAR,0x0801	; PS/2 Status
000001bd	84805000	lpl		r8			; Read Status
000001be	2B880001	andi	r8,r8,0x1	; =1 when char received
000001bf	C3000004	bez 	checkUARTStat
000001c0	42500800	lix 	PAR,0x0800	; PS/2 Data
000001c1	84805000	lpl		r8
000001c2	C0000007	bra		gotPS2Char
checkUARTStat:
000001c3	42501800	lix		PAR,0x1800	; UART Status
000001c4	84805000	lpl		r8			; Read Status
000001c5	2B880001	andi 	r8,r8,0x1	; =1 when char received
000001c6	C3FFFFF6	bez 	checkCharFromPS2
000001c7	42501801	lix 	PAR,0x1801	; UART Data
000001c8	84805000	lpl		r8
gotPS2Char:
000001c9	A1504000	pull	PAR
000001ca	A1704000	pull	PC

; checkForCharAndDiscard - Check for a character in UART or PS/2
; Discard the character received
; return whether char was present (1) or no char was present (0)

checkForCharAndDiscard:
000001cb	A0405000	push	PAR
000001cc	42500801	lix		PAR,0x0801	; PS/2 Status
000001cd	84805000	lpl		r8			; Read Status
000001ce	2B880001	andi	r8,r8,0x1	; =1 when char received
000001cf	C3000005	bez 	checkUARTStat2
000001d0	42500800	lix 	PAR,0x0800	; PS/2 Data
000001d1	84805000	lpl		r8			; throw away char
000001d2	42800001	lix		r8,0x1
000001d3	C000000A	bra		gotChar
checkUARTStat2:
000001d4	42501800	lix		PAR,0x1800	; UART Status
000001d5	84805000	lpl		r8			; Read Status
000001d6	2B880001	andi 	r8,r8,0x1	; =1 when char received
000001d7	C3000005	bez 	noCharReceived
000001d8	42501801	lix 	PAR,0x1801	; UART Data
000001d9	84805000	lpl		r8
000001da	42800001	lix		r8,1
000001db	C0000002	bra		gotChar
noCharReceived:
000001dc	42800000	lix		r8,0
gotChar:
000001dd	A1504000	pull	PAR
000001de	A1704000	pull	PC

;
; waitCharPolled_PS2 - Check the polled character interface
; wait for a character
; return when a character is present
; returns character received in r8
;

waitCharPolled_PS2:
000001df	A0405000	push	PAR
000001e0	42500803	lix		PAR,0x0803	; PS/2 Status
waitPS2RxStatPolled:
000001e1	84805000	lpl		r8			; Read Status into r8
000001e2	2B880001	andi 	r8,r8,0x1
000001e3	C3FFFFFE	bez 	waitPS2RxStatPolled
getCharFromPS2Polled:
000001e4	42500802	lix 	PAR,0x0802
000001e5	84805000	lpl		r8
whilePS2RxStatPolled:
000001e6	A1504000	pull	PAR
000001e7	A1704000	pull	PC

;
; checkGetStat_PS2 - Checks the polling status
; Polled interface is active while the keyboard key is pressed
; returns
;	-1 if there is no character,
;	character if there is a character
;

checkGetStat_PS2:
000001e8	A0405000	push	PAR
000001e9	42500803	lix		PAR,0x0803	; PS/2 Status
000001ea	84805000	lpl		r8			; Read Status into r8
000001eb	2B880001	andi	r8,r8,0x1
000001ec	C3000004	bez		charNotPresent
000001ed	42500802	lix		PAR,0x0802
000001ee	84805000	lpl		r8
000001ef	C0000002	bra		gotCharIn
charNotPresent:
000001f0	20802000	add		r8,ZERO,MINUS1
gotCharIn:
000001f1	A1504000	pull	PAR
000001f2	A1704000	pull	PC
;--------------------------------------------------------------------
; uart.asm

0000000a	missingHandshake: .string "*** Run PuTTY and enable hardware handshake ***"

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
000001f3	A0405000	push	PAR
000001f4	42501800	lix		PAR,0x1800	; UART Status
waitUartRxStat:
000001f5	84805000	lpl		r8			; Read Status into r8
000001f6	2B880001	andi 	r8,r8,0x1
000001f7	C3FFFFFE	bez 	waitUartRxStat
000001f8	42501801	lix 	PAR,0x1801
000001f9	84805000	lpl		r8
000001fa	A1504000	pull	PAR
000001fb	A1704000	pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
; -- status reg
; --     7              6                5         4          3        2         1         0
; --    irq   |   parity error      | overrun | frame err | n_cts  | n_dcd |  tx empty | rx full

;

putChar_UART:
000001fc	A0405000	push	PAR
000001fd	A0408000	push	r8
000001fe	42501800	lix		PAR,0x1800	; UART Status
waitUartTxStat:
000001ff	84805000	lpl		r8			; Read Status into r8
00000200	2B880002	andi 	r8,r8,0x2
00000201	C7000001	bnz 	uartRdy
; Remind user to enable HW handshake
; would be better to add a HW handshake timeout
; Since the USB is so much faster it is unlikely this path
;	will be exercised.
; For cards with RS-232 serial this would be a serious concern
; It's more likely that PuTTY needed to be run in HW handshake mode.
; handshakeStuck:
; lix		r8,missingHandshake.lower
; bsr		printString_ANSI
; pull	r8
; bra		getOut
uartRdy:
00000202	42501801	lix 	PAR,0x1801
00000203	A1804000	pull	r8
00000204	85508000	spl		r8			; echo the character
getOut:
00000205	A1504000	pull	PAR
00000206	A1704000	pull	PC

;--------------------------------------------------------------------
; timers.asm

0000000b	longTimeWait:	.long 0x0
0000000c	longTimeDelta:	.long 0x0

;
; setTimer_mS - sets a software timer in mSec from the current mSec time
; Non-blocking routine
; Wrap around problem at 2^32 mS (every 4.3 million seconds = 49 days)
; Timer is checked from checkForCountReached_mS routine
; longTimeWait - global that contains the terminal count time
; r8 is the number of mS until the counter expires
;

setTimer_mS:
00000207	A0408000	push	r8
00000208	A0409000	push	r9
00000209	A0406000	push	DAR
0000020a	A0405000	push	PAR
0000020b	42600160	lix		DAR,longTimeDelta.lower
0000020c	65608000	sdl		r8				; keep the delta time - might use it again
0000020d	42503802	lix		PAR,0x3802		; address of the mSec counter
0000020e	84905000	lpl		r9				; read the peripheral counter into r9
0000020f	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
00000210	4260015C	lix		DAR,longTimeWait.lower
00000211	65608000	sdl		r8
00000212	A1504000	pull	PAR
00000213	A1604000	pull	DAR
00000214	A1904000	pull	r9
00000215	A1804000	pull	r8
00000216	A1704000	pull	PC

;
; checkForCountReached_mS
; Presumptively reloads the terminal count for the next cycle
;	Can be over-riden by calling setTimer_mS again
; Returns
; r8 - 0 = Counter is not yet expired
;      1 = Counter is expired
;

checkForCountReached_mS:
00000217	A0409000	push	r9
00000218	A0406000	push	DAR
00000219	A0405000	push	PAR
0000021a	4260015C	lix		DAR,longTimeWait.lower
0000021b	64806000	ldl		r8
0000021c	42503802	lix		PAR,0x3802		; address of the mSec counter
0000021d	84905000	lpl		r9				; read the peripheral counter into r9
0000021e	38398000	cmp		r9,r8
0000021f	CF000008	bgt		returnTimerNotYet
00000220	42600160	lix		DAR,longTimeDelta.lower
00000221	64806000	ldl		r8				;  See, we did use the delta time again
00000222	20889000	add		r8,r8,r9
00000223	4260015C	lix		DAR,longTimeWait.lower
00000224	65608000	sdl		r8
00000225	42800001	lix		r8,0x1
00000226	C0000002	bra		timerDone
returnTimerNotYet:
00000227	42800000	lix		r8,0x0
timerDone:
00000228	A1504000	pull	PAR
00000229	A1604000	pull	DAR
0000022a	A1904000	pull	r9
0000022b	A1704000	pull	PC

; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
0000022c	A0409000	push	r9
0000022d	42503802	lix		PAR,0x3802		; address of the mSec counter
0000022e	84905000	lpl		r9				; read the peripheral counter into r9
0000022f	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
00000230	84905000	lpl		r9				; check the elapsed time counter
00000231	38389000	cmp		r8,r9
00000232	CCFFFFFE	blt		loop_delay_mS
00000233	A1904000	pull	r9
00000234	A1704000	pull	PC

;
; delay_uS - delay for the number of uSecs
; pass mSec delay in r8
; Uses routine uses r9 (saved and restored)
;

delay_uS:
00000235	A0409000	push	r9
00000236	A0405000	push	PAR
00000237	42503801	lix		PAR,0x3801		; address of the uSec counter
00000238	84905000	lpl		r9				; read the peripheral counter into r9
00000239	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_uS:
0000023a	84905000	lpl		r9				; check the elapsed time counter
0000023b	38389000	cmp		r8,r9
0000023c	CCFFFFFE	blt		loop_delay_uS
0000023d	A1504000	pull	PAR
0000023e	A1904000	pull	r9
0000023f	A1704000	pull	PC

;
; randomNumber_8bits - Generate a random number - 8-bit value
; 0x3803 is the Processor Instruction Cycle counter
; r8 - random number returned in r8
;

randomNumber_8bits:
00000240	A0405000	push	PAR
00000241	42503803	lix		PAR,0x3803
00000242	84805000	lpl		r8
00000243	32808000	sr1		r8,r8
00000244	32808000	sr1		r8,r8
00000245	2B8800FF	andi	r8,r8,0xff
00000246	A1504000	pull	PAR
00000247	A1704000	pull	PC

;--------------------------------------------------------------------
; switches.asm

;
; readSws
; switches value returned in r8
; switches are high when pressed
; Switches d0-d2 are the pushbutton switches (inverted in FPGA hardware)
; 	Pushbutton switches are debounced
; Switches d3-10 are the DIP switches (not inverted)
;

readSws:
00000248	A0405000	push	PAR
00000249	42502000	lix		PAR,0x2000	; Switches address
0000024a	84805000	lpl		r8			; Read switches into r9
0000024b	2B880FFF	andi	r8,r8,0xfff	; just the switches
0000024c	A1504000	pull	PAR
0000024d	A1704000	pull	PC

;--------------------------------------------------------------------
; SevenSegLEDs.asm

; wr7Seg8Dig
; passed r8 - value to send to the 7 seg display

wr7Seg8Dig:
0000024e	A0405000	push	PAR
0000024f	A0408000	push	r8
00000250	42503000	lix		PAR,0x3000		; Seven Segment LED lines
00000251	85508000	spl		r8				; Write out LED bits
00000252	A1804000	pull	r8
00000253	A1504000	pull	PAR
00000254	A1704000	pull	PC

;
; hexToSevenSeg - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg:
00000255	A0409000	push	r9
00000256	A0406000	push	DAR
00000257	A0405000	push	PAR
00000258	42900000	lix		r9,0
00000259	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
0000025a	68806000	ldbp	r8
0000025b	D4FFFECD	bsr		asciiToHex_ANSI_UART
0000025c	2B88000F	andi	r8,r8,0xf
0000025d	28998000	or		r9,r9,r8
0000025e	30909000	sl1		r9,r9
0000025f	30909000	sl1		r9,r9
00000260	30909000	sl1		r9,r9
00000261	30909000	sl1		r9,r9
00000262	60806000	ldb		r8
00000263	D4FFFEC5	bsr		asciiToHex_ANSI_UART
00000264	2B88000F	andi	r8,r8,0xf
00000265	28998000	or		r9,r9,r8
00000266	42503000	lix		PAR,0x3000		; seven segment display
00000267	85509000	spl		r9
00000268	20890000	add		r8,r9,ZERO
00000269	A1504000	pull	PAR
0000026a	A1604000	pull	DAR
0000026b	A1904000	pull	r9
0000026c	A1704000	pull	PC

;--------------------------------------------------------------------
; bufferedIO.asm - collection of buffered I/O routines
;
; readToLineBuffer - Reads the UART and fills a buffer with the characters received
; r8 received character - Character received from the UART
; r9 is the input buffer length
; r10 used to test the backspace doesn't go past the start of the buffer
; DAR points to lineBuff current character position
;

readToLineBuffer:
0000026d	A0408000	push	r8
0000026e	A0409000	push	r9
0000026f	A040A000	push	r10
00000270	A0406000	push	DAR
00000271	42600018	lix		DAR,lineBuff.lower	; DAR pointer = start of line buffer
00000272	4290004F	lix		r9,79				; number of chars in the line buffer
loopReadLine:
00000273	D4FFFF48	bsr		waitReadPS2_UART	; Get a character from the UART
00000274	D4FFFEB1	bsr		write_ANSI_UART		; Echo character back to the UART
00000275	3938000D	cmpi	r8,0x0D				; check if received char was end of line
00000276	D1000006	beq		gotEOL
00000277	3938007F	cmpi	r8,0x7F
00000278	D1000009	beq		gotBackspace
00000279	69608000	sdbp	r8
0000027a	20992000	add		r9,r9,MINUS1
0000027b	C7FFFFF8	bnz		loopReadLine		; Next char would overflow
; tbd add code for line too long
gotEOL:
0000027c	4280000A	lix		r8,0x0A				; Echo line feed after CR
0000027d	D4FFFEA8	bsr		write_ANSI_UART	; Put the character to the screen
0000027e	D4FFFF7E	bsr		putChar_UART		; Echo character back to the UART
0000027f	61600000	sdb		r0					; null at end of line read
00000280	C0000007	bra		doneHandlingLine
gotBackspace:
00000281	20662000	add		DAR,DAR,MINUS1
00000282	42A00018	lix		r10,lineBuff.lower	; r10 pointer = start of line buffer
00000283	383A6000	cmp		r10,DAR
00000284	CFFFFFEF	bgt		loopReadLine
00000285	216A0000	addi	DAR,r10,0
00000286	C0FFFFED	bra		loopReadLine
doneHandlingLine:
00000287	A1604000	pull	DAR
00000288	A1A04000	pull	r10
00000289	A1904000	pull	r9
0000028a	A1804000	pull	r8
0000028b	A1704000	pull	PC

;
; printLong
; r8 contains the long value to print
;

printLong:
0000028c	A0408000	push	r8
0000028d	A0409000	push	r9
0000028e	A040A000	push	r10
0000028f	A0408000	push	r8				; temporarily save r8
00000290	42800030	lix		r8,0x30
00000291	D4FFFE94	bsr		write_ANSI_UART
00000292	42800078	lix		r8,0x78
00000293	D4FFFE92	bsr		write_ANSI_UART
00000294	A1804000	pull	r8				; restore r8
00000295	42900008	lix		r9,8			; loop counter
doNextPrintLong:
00000296	34808000	rol1	r8,r8
00000297	34808000	rol1	r8,r8
00000298	34808000	rol1	r8,r8
00000299	34808000	rol1	r8,r8
0000029a	D4000007	bsr		printHexVal
0000029b	23990001	subi	r9,r9,1
0000029c	C7FFFFFA	bnz		doNextPrintLong
0000029d	A1A04000	pull	r10
0000029e	A1904000	pull	r9
0000029f	A1804000	pull	r8
000002a0	A1704000	pull	PC

;
; printHexVal
;

printHexVal:
000002a1	A0408000	push	r8
000002a2	2B88000F	andi	r8,r8,0xf
000002a3	39380009	cmpi	r8,9
000002a4	CC000004	blt		printHexLetter
000002a5	21880030	addi	r8,r8,0x30
000002a6	D4FFFE7F	bsr		write_ANSI_UART
000002a7	C0000003	bra		donePrintHexVal
printHexLetter:
000002a8	21880037	addi	r8,r8,0x37		; 'A' - 10
000002a9	D4FFFE7C	bsr		write_ANSI_UART
donePrintHexVal:
000002aa	A1804000	pull	r8
000002ab	A1704000	pull	PC

