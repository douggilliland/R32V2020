; Read PS/2 keyboard character in polled mode
; Put character to the Screen
; Requires V002 Peripherals build with ANSI screen support
; On RETRO-EP4 card, requires PuTTY to be running to read serial port
; PuTTY needs to be in Hardware Handshake mode
; SigRok PS/2 decoder https://www.sigrok.org/blog/new-protocol-decoder-ps2

prompt:	.string "R32V2020> "
;missingHandshake: .string "*** Run PuTTY and enable hardware handshake ***"
screenPtr:	.long 0x0000
screenBase:	.long 0x0

;
; Read PS/2 character and put it to the SVGA Display and the Serial Port
;

main:
00000000	D40000B7	bsr		clearScreen_ANSI
00000001	42800000	lix		r8,prompt.lower
00000002	D400008D	bsr		printString_ANSI
soundOff:
00000003	4290003F	lix		r9,0x3F				; Sound generator note off (middle of range)
00000004	42504000	lix		PAR,0x4000			; Sound generator
00000005	85509000	spl		r9					; shut note off
loopPS2Read_ScreenWrite:
00000006	D4000054	bsr		checkGetStat_PS2	; Check for polled char
00000007	38382000	cmp		r8,MINUS1
00000008	D1FFFFFB	beq		soundOff
00000009	2B88007F	andi	r8,r8,0x7f			; mask the non-note bits
0000000a	29880080	ori		r8,r8,0x80			; turn on the note enable
0000000b	42504000	lix		PAR,0x4000			; Sound generator
0000000c	85508000	spl		r8
0000000d	4280000A	lix		r8,10				; set the delay between repeats
0000000e	D4000002	bsr		delay_mS
0000000f	C0FFFFF7	bra		loopPS2Read_ScreenWrite

;--------------------------------------------------------------------
; timers.asm

; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
00000010	A0409000	push	r9
00000011	42503802	lix		PAR,0x3802		; address of the mSec counter
00000012	84905000	lpl		r9				; read the peripheral counter into r9
00000013	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
00000014	84905000	lpl		r9				; check the elapsed time counter
00000015	38389000	cmp		r8,r9
00000016	CCFFFFFE	blt		loop_delay_mS
00000017	A1904000	pull	r9
00000018	A1704000	pull	PC

;
; delay_uS - delay for the number of uSecs
; pass mSec delay in r8
; Uses routine uses r9 (saved and restored)
;

delay_uS:
00000019	A0409000	push	r9
0000001a	A0405000	push	PAR
0000001b	42503801	lix		PAR,0x3801		; address of the uSec counter
0000001c	84905000	lpl		r9				; read the peripheral counter into r9
0000001d	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_uS:
0000001e	84905000	lpl		r9				; check the elapsed time counter
0000001f	38389000	cmp		r8,r9
00000020	CCFFFFFE	blt		loop_delay_uS
00000021	A1504000	pull	PAR
00000022	A1904000	pull	r9
00000023	A1704000	pull	PC

;--------------------------------------------------------------------
; ps2.asm - Functions to read the PS/2 keyboard
;
; Address	Function
; x0800 	Latched Keyboard Data
; x0801 	Latched Keyboard Status
; x0802 	Polled Keyboard Data
; x0803 	Polled Keyboard Status
;
; getChar_PS2
; returns character received in r8
;

getChar_PS2:
00000024	A0405000	push	PAR
00000025	42500801	lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
00000026	84805000	lpl		r8			; Read Status into r9
00000027	2B880001	andi 	r8,r8,1
00000028	C3FFFFFE	bez 	waitPS2RxStat
getCharFromPS2:
00000029	42500800	lix 	PAR,0x0800
0000002a	84805000	lpl		r8
whilePS2RxStat:
0000002b	A1504000	pull	PAR
0000002c	A1704000	pull	PC

; waitReadPS2_UART
; wait for character from either
;	the PS/2 keyboard or the UART serial
; r8 = read character

waitReadPS2_UART:
0000002d	A0405000	push	PAR
checkCharFromPS2:
0000002e	42500801	lix		PAR,0x0801	; PS/2 Status
0000002f	84805000	lpl		r8			; Read Status
00000030	2B880001	andi	r8,r8,0x1	; =1 when char received
00000031	C3000004	bez 	checkUARTStat
00000032	42500800	lix 	PAR,0x0800	; PS/2 Data
00000033	84805000	lpl		r8
00000034	C0000007	bra		gotPS2Char
checkUARTStat:
00000035	42501800	lix		PAR,0x1800	; UART Status
00000036	84805000	lpl		r8			; Read Status
00000037	2B880001	andi 	r8,r8,0x1	; =1 when char received
00000038	C3FFFFF6	bez 	checkCharFromPS2
00000039	42501801	lix 	PAR,0x1801	; UART Data
0000003a	84805000	lpl		r8
gotPS2Char:
0000003b	A1504000	pull	PAR
0000003c	A1704000	pull	PC

; checkForCharAndDiscard - Check for a character in UART or PS/2
; Discard the character received
; return whether char was present (1) or no char was present (0)

checkForCharAndDiscard:
0000003d	A0405000	push	PAR
0000003e	42500801	lix		PAR,0x0801	; PS/2 Status
0000003f	84805000	lpl		r8			; Read Status
00000040	2B880001	andi	r8,r8,0x1	; =1 when char received
00000041	C3000005	bez 	checkUARTStat2
00000042	42500800	lix 	PAR,0x0800	; PS/2 Data
00000043	84805000	lpl		r8			; throw away char
00000044	42800001	lix		r8,0x1
00000045	C000000A	bra		gotChar
checkUARTStat2:
00000046	42501800	lix		PAR,0x1800	; UART Status
00000047	84805000	lpl		r8			; Read Status
00000048	2B880001	andi 	r8,r8,0x1	; =1 when char received
00000049	C3000005	bez 	noCharReceived
0000004a	42501801	lix 	PAR,0x1801	; UART Data
0000004b	84805000	lpl		r8
0000004c	42800001	lix		r8,1
0000004d	C0000002	bra		gotChar
noCharReceived:
0000004e	42800000	lix		r8,0
gotChar:
0000004f	A1504000	pull	PAR
00000050	A1704000	pull	PC

;
; waitCharPolled_PS2 - Check the polled character interface
; wait for a character
; return when a character is present
; returns character received in r8
;

waitCharPolled_PS2:
00000051	A0405000	push	PAR
00000052	42500803	lix		PAR,0x0803	; PS/2 Status
waitPS2RxStatPolled:
00000053	84805000	lpl		r8			; Read Status into r8
00000054	2B880001	andi 	r8,r8,0x1
00000055	C3FFFFFE	bez 	waitPS2RxStatPolled
getCharFromPS2Polled:
00000056	42500802	lix 	PAR,0x0802
00000057	84805000	lpl		r8
whilePS2RxStatPolled:
00000058	A1504000	pull	PAR
00000059	A1704000	pull	PC

;
; checkGetStat_PS2 - Checks the polling status
; Polled interface is active while the keyboard key is pressed
; returns
;	-1 if there is no character,
;	character if there is a character
;

checkGetStat_PS2:
0000005a	A0405000	push	PAR
0000005b	42500803	lix		PAR,0x0803	; PS/2 Status
0000005c	84805000	lpl		r8			; Read Status into r8
0000005d	2B880001	andi	r8,r8,0x1
0000005e	C3000004	bez		charNotPresent
0000005f	42500802	lix		PAR,0x0802
00000060	84805000	lpl		r8
00000061	C0000002	bra		gotCharIn
charNotPresent:
00000062	20802000	add		r8,ZERO,MINUS1
gotCharIn:
00000063	A1504000	pull	PAR
00000064	A1704000	pull	PC
;--------------------------------------------------------------------
; uart.asm

missingHandshake: .string "*** Run PuTTY and enable hardware handshake ***"

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
00000065	A0405000	push	PAR
00000066	42501800	lix		PAR,0x1800	; UART Status
waitUartRxStat:
00000067	84805000	lpl		r8			; Read Status into r8
00000068	2B880001	andi 	r8,r8,0x1
00000069	C3FFFFFE	bez 	waitUartRxStat
0000006a	42501801	lix 	PAR,0x1801
0000006b	84805000	lpl		r8
0000006c	A1504000	pull	PAR
0000006d	A1704000	pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putChar_UART:
0000006e	A0405000	push	PAR
0000006f	A0408000	push	r8
00000070	42501800	lix		PAR,0x1800	; UART Status
waitUartTxStat:
00000071	84805000	lpl		r8			; Read Status into r8
00000072	2B880002	andi 	r8,r8,0x2
00000073	C7000005	bnz 	uartRdy
; Remind user to enable HW handshake
; would be better to add a HW handshake timeout
; Since the USB is so much faster it is unlikely this path
;	will be exercised.
; For cards with RS-232 serial this would be a serious concern
; It's more likely that PuTTY needed to be run in HW handshake mode.
handshakeStuck:
00000074	42800014	lix		r8,missingHandshake.lower
00000075	D400001A	bsr		printString_ANSI
00000076	A1804000	pull	r8
00000077	C0000004	bra		getOut
uartRdy:
00000078	42501801	lix 	PAR,0x1801
00000079	A1804000	pull	r8
0000007a	85508000	spl		r8			; echo the character
getOut:
0000007b	A1504000	pull	PAR
0000007c	A1704000	pull	PC

;--------------------------------------------------------------------
; ANSIScreen.asm

;
; putChar_ANSI - Put a character to the screen
; Character to put to screen is in r8
;

putChar_ANSI:
0000007d	A0409000	push	r9
0000007e	A0405000	push	PAR
0000007f	42500000	lix		PAR,0x0		; UART Status
waitScreenTxStat:
00000080	84905000	lpl		r9			; Read Status into r9
00000081	2B990002	andi	r9,r9,0x2
00000082	C3FFFFFE	bez 	waitScreenTxStat
00000083	42500001	lix 	PAR,0x1
00000084	85508000	spl		r8			; echo the character
00000085	A1504000	pull	PAR
00000086	A1904000	pull	r9
00000087	A1704000	pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
00000088	A0408000	push	r8
00000089	4280000A	lix		r8,0x0A				; Line Feed
0000008a	D4FFFFF3	bsr		putChar_ANSI	; Put the character to the screen
0000008b	4280000D	lix		r8,0x0D				; Carriage Return
0000008c	D4FFFFF1	bsr		putChar_ANSI	; Echo character back to the UART
0000008d	A1804000	pull	r8
0000008e	A1704000	pull	PC

;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
0000008f	A0408000	push	r8					; save r8
00000090	A0406000	push	DAR
00000091	20680000	add		DAR,r8,ZERO			; set the start of the string
nextCharANSI:
00000092	68806000	ldbp	r8					; get the character01
00000093	39380000	cmpi	r8,0x0				; Null terminated string
00000094	D1000003	beq		donePrANSIStr		; done if null
00000095	D4FFFFE8	bsr		putChar_ANSI	; write out the character
00000096	C0FFFFFC	bra		nextCharANSI
donePrANSIStr:
00000097	A1604000	pull	DAR					; restore DAR
00000098	A1804000	pull	r8					; restore r8
00000099	A1704000	pull	PC					; rts

;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
0000009a	A0408000	push	r8
0000009b	A0409000	push	r9
0000009c	A0408000	push	r8				; temporarily save r8
0000009d	A1804000	pull	r8				; restore r8
0000009e	42900002	lix		r9,2			; loop counter
0000009f	31808000	sl8		r8,r8
000000a0	31808000	sl8		r8,r8
000000a1	31808000	sl8		r8,r8
doNextprintByte_ANSI:
000000a2	34808000	rol1	r8,r8
000000a3	34808000	rol1	r8,r8
000000a4	34808000	rol1	r8,r8
000000a5	34808000	rol1	r8,r8
000000a6	D4000006	bsr		printHexVal_ANSI
000000a7	23990001	subi	r9,r9,1
000000a8	C7FFFFFA	bnz		doNextprintByte_ANSI
000000a9	A1904000	pull	r9
000000aa	A1804000	pull	r8
000000ab	A1704000	pull	PC

;
; printHexValANSI
;

printHexVal_ANSI:
000000ac	A0408000	push	r8
000000ad	2B88000F	andi	r8,r8,0xf
000000ae	39380009	cmpi	r8,9
000000af	CC000004	blt		printHexLetterANSI
000000b0	21880030	addi	r8,r8,0x30
000000b1	D4FFFFCC	bsr		putChar_ANSI
000000b2	C0000003	bra		donePrintHexValANSI
printHexLetterANSI:
000000b3	21880037	addi	r8,r8,0x37		; 'A' - 10
000000b4	D4FFFFC9	bsr		putChar_ANSI
donePrintHexValANSI:
000000b5	A1804000	pull	r8
000000b6	A1704000	pull	PC

;
; clearScreen_ANSI - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
; No passed value
; Uses r8 (saved during function)
; no return value
;

clearScreen_ANSI:
000000b7	A0408000	push	r8				; save r8
000000b8	4280001B	lix		r8,0x1b			; ESC
000000b9	D4FFFFC4	bsr		putChar_ANSI
000000ba	4280005B	lix		r8,0x5b			; [
000000bb	D4FFFFC2	bsr		putChar_ANSI
000000bc	42800032	lix		r8,0x32			; 2
000000bd	D4FFFFC0	bsr		putChar_ANSI
000000be	4280004A	lix		r8,0x4A			; J
000000bf	D4FFFFBE	bsr		putChar_ANSI
000000c0	A1804000	pull	r8
000000c1	A1704000	pull	PC				; rts

;
; printLong_ANSI
; r8 contains the long value to print
;

printLong_ANSI:
000000c2	A0408000	push	r8
000000c3	A0409000	push	r9
000000c4	A0408000	push	r8				; temporarily save r8
000000c5	42800030	lix		r8,0x30			; print 0x
000000c6	D4FFFFB7	bsr		putChar_ANSI
000000c7	42800078	lix		r8,0x78
000000c8	D4FFFFB5	bsr		putChar_ANSI
000000c9	A1804000	pull	r8				; restore r8
000000ca	42900008	lix		r9,8			; loop counter
doNextprintLong_ANSI:
000000cb	34808000	rol1	r8,r8
000000cc	34808000	rol1	r8,r8
000000cd	34808000	rol1	r8,r8
000000ce	34808000	rol1	r8,r8
000000cf	D4FFFFDD	bsr		printHexVal_ANSI
000000d0	23990001	subi	r9,r9,1
000000d1	C7FFFFFA	bnz		doNextprintLong_ANSI
000000d2	A1904000	pull	r9
000000d3	A1804000	pull	r8
000000d4	A1704000	pull	PC
