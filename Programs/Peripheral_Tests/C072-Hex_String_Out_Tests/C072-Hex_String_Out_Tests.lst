;
; C072-Hex_String_Out_Tests - Send out a hex long as a string of 8 hex digitsRead
;

prompt:			.string "R32V2020> "
; lineBuff is 80 characters long
lineBuff:		.string "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
lineEnd:		.long 0x00
syntaxError:	.string "Syntax error... "

;
; Read UART character and put it to the ANSI VGA Display
; Turn the first two characters into a hex 8-bit value
;

main:
00000000	D40001AF	bsr		clearScreen_ANSI
00000001	42800000	lix		r8,prompt.lower
00000002	D4000185	bsr		printString_ANSI
00000003	4180DEAD	liu		r8,0xDEAD
00000004	4080BABA	lil		r8,0xBABA
00000005	D40001B5	bsr		printLong_ANSI
00000006	41801234	liu		r8,0x1234
00000007	4080ABCD	lil		r8,0xABCD
00000008	D40001B2	bsr		printLong_ANSI
00000009	01000000	hcf

;--------------------------------------------------------------------
; ps2.asm - Functions to read the PS/2 keyboard
;
; Address	Function
; x0800 	Latched Keyboard Data
; x0801 	Latched Keyboard Status
; x0802 	Polled Keyboard Data
; x0803 	Polled Keyboard Status
;
; getChar_PS2
; returns character received in r8
;

getChar_PS2:
0000000a	A0405000	push	PAR
0000000b	42500801	lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
0000000c	84805000	lpl		r8			; Read Status into r9
0000000d	2B880001	andi 	r8,r8,1
0000000e	C3FFFFFE	bez 	waitPS2RxStat
getCharFromPS2:
0000000f	42500800	lix 	PAR,0x0800
00000010	84805000	lpl		r8
whilePS2RxStat:
00000011	A1504000	pull	PAR
00000012	A1704000	pull	PC

; waitReadPS2_UART
; wait for character from either
;	the PS/2 keyboard or the UART serial
; r8 = read character

waitReadPS2_UART:
00000013	A0405000	push	PAR
checkCharFromPS2:
00000014	42500801	lix		PAR,0x0801	; PS/2 Status
00000015	84805000	lpl		r8			; Read Status
00000016	2B880001	andi	r8,r8,0x1	; =1 when char received
00000017	C3000004	bez 	checkUARTStat
00000018	42500800	lix 	PAR,0x0800	; PS/2 Data
00000019	84805000	lpl		r8
0000001a	C0000007	bra		gotPS2Char
checkUARTStat:
0000001b	42501800	lix		PAR,0x1800	; UART Status
0000001c	84805000	lpl		r8			; Read Status
0000001d	2B880001	andi 	r8,r8,0x1	; =1 when char received
0000001e	C3FFFFF6	bez 	checkCharFromPS2
0000001f	42501801	lix 	PAR,0x1801	; UART Data
00000020	84805000	lpl		r8
gotPS2Char:
00000021	A1504000	pull	PAR
00000022	A1704000	pull	PC

; checkForCharAndDiscard - Check for a character in UART or PS/2
; Discard the character received
; return whether char was present (1) or no char was present (0)

checkForCharAndDiscard:
00000023	A0405000	push	PAR
00000024	42500801	lix		PAR,0x0801	; PS/2 Status
00000025	84805000	lpl		r8			; Read Status
00000026	2B880001	andi	r8,r8,0x1	; =1 when char received
00000027	C3000005	bez 	checkUARTStat2
00000028	42500800	lix 	PAR,0x0800	; PS/2 Data
00000029	84805000	lpl		r8			; throw away char
0000002a	42800001	lix		r8,0x1
0000002b	C000000A	bra		gotChar
checkUARTStat2:
0000002c	42501800	lix		PAR,0x1800	; UART Status
0000002d	84805000	lpl		r8			; Read Status
0000002e	2B880001	andi 	r8,r8,0x1	; =1 when char received
0000002f	C3000005	bez 	noCharReceived
00000030	42501801	lix 	PAR,0x1801	; UART Data
00000031	84805000	lpl		r8
00000032	42800001	lix		r8,1
00000033	C0000002	bra		gotChar
noCharReceived:
00000034	42800000	lix		r8,0
gotChar:
00000035	A1504000	pull	PAR
00000036	A1704000	pull	PC

;
; waitCharPolled_PS2 - Check the polled character interface
; wait for a character
; return when a character is present
; returns character received in r8
;

waitCharPolled_PS2:
00000037	A0405000	push	PAR
00000038	42500803	lix		PAR,0x0803	; PS/2 Status
waitPS2RxStatPolled:
00000039	84805000	lpl		r8			; Read Status into r8
0000003a	2B880001	andi 	r8,r8,0x1
0000003b	C3FFFFFE	bez 	waitPS2RxStatPolled
getCharFromPS2Polled:
0000003c	42500802	lix 	PAR,0x0802
0000003d	84805000	lpl		r8
whilePS2RxStatPolled:
0000003e	A1504000	pull	PAR
0000003f	A1704000	pull	PC

;
; checkGetStat_PS2 - Checks the polling status
; Polled interface is active while the keyboard key is pressed
; returns
;	-1 if there is no character,
;	character if there is a character
;

checkGetStat_PS2:
00000040	A0405000	push	PAR
00000041	42500803	lix		PAR,0x0803	; PS/2 Status
00000042	84805000	lpl		r8			; Read Status into r8
00000043	2B880001	andi	r8,r8,0x1
00000044	C3000004	bez		charNotPresent
00000045	42500802	lix		PAR,0x0802
00000046	84805000	lpl		r8
00000047	C0000002	bra		gotCharIn
charNotPresent:
00000048	20802000	add		r8,ZERO,MINUS1
gotCharIn:
00000049	A1504000	pull	PAR
0000004a	A1704000	pull	PC
;--------------------------------------------------------------------
; uart.asm

missingHandshake: .string "*** Run PuTTY and enable hardware handshake ***"

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
0000004b	A0405000	push	PAR
0000004c	42501800	lix		PAR,0x1800	; UART Status
waitUartRxStat:
0000004d	84805000	lpl		r8			; Read Status into r8
0000004e	2B880001	andi 	r8,r8,0x1
0000004f	C3FFFFFE	bez 	waitUartRxStat
00000050	42501801	lix 	PAR,0x1801
00000051	84805000	lpl		r8
00000052	A1504000	pull	PAR
00000053	A1704000	pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putChar_UART:
00000054	A0405000	push	PAR
00000055	A0408000	push	r8
00000056	42501800	lix		PAR,0x1800	; UART Status
waitUartTxStat:
00000057	84805000	lpl		r8			; Read Status into r8
00000058	2B880002	andi 	r8,r8,0x2
00000059	C7000005	bnz 	uartRdy
; Remind user to enable HW handshake
; would be better to add a HW handshake timeout
; Since the USB is so much faster it is unlikely this path
;	will be exercised.
; For cards with RS-232 serial this would be a serious concern
; It's more likely that PuTTY needed to be run in HW handshake mode.
handshakeStuck:
0000005a	42800078	lix		r8,missingHandshake.lower
0000005b	D400012C	bsr		printString_ANSI
0000005c	A1804000	pull	r8
0000005d	C0000004	bra		getOut
uartRdy:
0000005e	42501801	lix 	PAR,0x1801
0000005f	A1804000	pull	r8
00000060	85508000	spl		r8			; echo the character
getOut:
00000061	A1504000	pull	PAR
00000062	A1704000	pull	PC

;--------------------------------------------------------------------
; ANSI_UART_io.asm

;
; ANSI_UART_io.asm -
;

;
; printString_ANSI_UART - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI_UART:
00000063	A0408000	push	r8					; save r8
00000064	A0406000	push	DAR
00000065	20680000	add		DAR,r8,ZERO			; set the start of the string
nextChar:
00000066	68806000	ldbp	r8					; get the character01
00000067	39380000	cmpi	r8,0x0				; Null terminated string
00000068	D1000003	beq		donePrStr			; done if null
00000069	D4000023	bsr		write_ANSI_UART	; write out the character
0000006a	C0FFFFFC	bra		nextChar
donePrStr:
0000006b	A1604000	pull	DAR					; restore DAR
0000006c	A1804000	pull	r8					; restore r8
0000006d	A1704000	pull	PC					; rts

;
; printLinebuffer_ANSI_UART - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLinebuffer_ANSI_UART:
0000006e	A0408000	push	r8					; save r8
0000006f	A0406000	push	DAR
00000070	21680000	addi	DAR,r8,0x0			; set the start of the string
nextChar2:
00000071	68806000	ldbp	r8					; get the character
00000072	39380000	cmpi	r8,0x0				; Null terminated string
00000073	D1000003	beq		donePrStr2			; done if null
00000074	D4000018	bsr		write_ANSI_UART	; write out the character
00000075	C0FFFFFC	bra		nextChar2
donePrStr2:
00000076	D4000004	bsr		newLine_ANSI_UART
00000077	A1604000	pull	DAR					; restore DAR
00000078	A1804000	pull	r8					; restore r8
00000079	A1704000	pull	PC					; rts

;
; newLine_ANSI_UART - Print out a newLine_ANSI_UART (CR-LF)
;

newLine_ANSI_UART:
0000007a	A0408000	push	r8
0000007b	4280000A	lix		r8,0x0A				; Line Feed
0000007c	D4000010	bsr		write_ANSI_UART	; Put the character to the screen
0000007d	4280000D	lix		r8,0x0D				; Carriage Return
0000007e	D400000E	bsr		write_ANSI_UART		; Echo character back to the UART
0000007f	A1804000	pull	r8
00000080	A1704000	pull	PC

;
; clearScreen_ANSI_UART - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen_ANSI_UART:
00000081	A0408000	push	r8				; save r8
00000082	4280001B	lix		r8,0x1b			; ESC
00000083	D4000009	bsr		write_ANSI_UART
00000084	4280005B	lix		r8,0x5b			; [
00000085	D4000007	bsr		write_ANSI_UART
00000086	42800032	lix		r8,0x32			; 2
00000087	D4000005	bsr		write_ANSI_UART
00000088	4280004A	lix		r8,0x4A			; J
00000089	D4000003	bsr		write_ANSI_UART
0000008a	A1804000	pull	r8
0000008b	A1704000	pull	PC				; rts

; write_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

write_ANSI_UART:
0000008c	D40000E1	bsr		putChar_ANSI
0000008d	D4FFFFC7	bsr		putChar_UART
0000008e	A1704000	pull	PC

;
; asciiToHex_ANSI_UART - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

asciiToHex_ANSI_UART:
0000008f	39380066	cmpi	r8,0x66			; past 'f'
00000090	CC000011	blt		a2h_Error
00000091	39380030	cmpi	r8,0x30			; below '0'
00000092	CF00000F	bgt		a2h_Error
00000093	3938003A	cmpi	r8,0x3A			; '0' - '9'
00000094	CF000009	bgt		gotDigit
00000095	39380041	cmpi	r8,0x41			; ':' - '@'
00000096	CF00000B	bgt		a2h_Error
00000097	39380047	cmpi	r8,0x47			; 'A' - 'F'
00000098	CC000007	blt		gotUpperLetter
00000099	39380061	cmpi	r8,0x61			; 'G' - 'tick'
0000009a	CC000007	blt		a2h_Error
; Lower case letter
0000009b	23880057	subi	r8,r8,0x57
0000009c	C000000A	bra		doneConvA2H
; number 0-9
gotDigit:
0000009d	23880030	subi	r8,r8,0x30
0000009e	C0000008	bra		doneConvA2H
; A-F
gotUpperLetter:
0000009f	23880037	subi	r8,r8,0x37
000000a0	C0000006	bra		doneConvA2H
a2h_Error:
000000a1	42800064	lix		r8,syntaxError.lower
000000a2	D4FFFFD8	bsr		newLine_ANSI_UART
000000a3	D4FFFFC0	bsr		printString_ANSI_UART
000000a4	D4FFFFD6	bsr		newLine_ANSI_UART
000000a5	4280DEAD	lix		r8,0xDEAD
doneConvA2H:
000000a6	A1704000	pull	PC

; hexToSevenSeg_ANSI_UART - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg_ANSI_UART:
000000a7	A0409000	push	r9
000000a8	A0406000	push	DAR
000000a9	A0405000	push	PAR
000000aa	42900000	lix		r9,0
000000ab	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
000000ac	68806000	ldbp	r8
000000ad	D4FFFFE2	bsr		asciiToHex_ANSI_UART
000000ae	3938DEAD	cmpi	r8,0xDEAD
000000af	D1000011	beq		badHexVal
000000b0	2B88000F	andi	r8,r8,0xf
000000b1	28998000	or		r9,r9,r8
000000b2	30909000	sl1		r9,r9
000000b3	30909000	sl1		r9,r9
000000b4	30909000	sl1		r9,r9
000000b5	30909000	sl1		r9,r9
000000b6	60806000	ldb		r8
000000b7	D4FFFFD8	bsr		asciiToHex_ANSI_UART
000000b8	3938DEAD	cmpi	r8,0xDEAD
000000b9	D1000007	beq		badHexVal
000000ba	2B88000F	andi	r8,r8,0xf
000000bb	28998000	or		r9,r9,r8
000000bc	42503000	lix		PAR,0x3000		; seven segment display
000000bd	85509000	spl		r9
000000be	20890000	add		r8,r9,ZERO
000000bf	C0000006	bra		valOKDone
badHexVal:
000000c0	42800064	lix		r8,syntaxError.lower
000000c1	D4FFFFB9	bsr		newLine_ANSI_UART
000000c2	D4FFFFA1	bsr		printString_ANSI_UART
000000c3	D4FFFFB7	bsr		newLine_ANSI_UART
000000c4	4280DEAD	lix		r8,0xDEAD
valOKDone:
000000c5	A1504000	pull	PAR
000000c6	A1604000	pull	DAR
000000c7	A1904000	pull	r9
000000c8	A1704000	pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI_UART:
000000c9	A0408000	push	r8
000000ca	2B88000F	andi	r8,r8,0xf
000000cb	39380009	cmpi	r8,9
000000cc	CC000004	blt		printHexLetterANSI_UART
000000cd	21880030	addi	r8,r8,0x30
000000ce	D4FFFFBE	bsr		write_ANSI_UART
000000cf	C0000003	bra		doneprintHexValANSI_UART
printHexLetterANSI_UART:
000000d0	21880037	addi	r8,r8,0x37		; 'A' - 10
000000d1	D4FFFFBB	bsr		write_ANSI_UART
doneprintHexValANSI_UART:
000000d2	A1804000	pull	r8
000000d3	A1704000	pull	PC

;
; printByte_ANSI_UART
; r8 contains the short value to print
;

printByte_ANSI_UART:
000000d4	A0408000	push	r8
000000d5	A0409000	push	r9
000000d6	A0408000	push	r8				; temporarily save r8
000000d7	42800030	lix		r8,0x30			; print 0x
000000d8	D400003E	bsr		putChar_ANSI_UART
000000d9	42800078	lix		r8,0x78
000000da	D400003C	bsr		putChar_ANSI_UART
000000db	A1804000	pull	r8				; restore r8
000000dc	42900002	lix		r9,2			; loop counter
000000dd	31808000	sl8		r8,r8
000000de	31808000	sl8		r8,r8
000000df	31808000	sl8		r8,r8
doNextprintByte_ANSI_UART:
000000e0	34808000	rol1	r8,r8
000000e1	34808000	rol1	r8,r8
000000e2	34808000	rol1	r8,r8
000000e3	34808000	rol1	r8,r8
000000e4	D4FFFFE5	bsr		printHexVal_ANSI_UART
000000e5	23990001	subi	r9,r9,1
000000e6	C7FFFFFA	bnz		doNextprintByte_ANSI_UART
000000e7	A1904000	pull	r9
000000e8	A1804000	pull	r8
000000e9	A1704000	pull	PC

;
; printShort_ANSI_UART
; r8 contains the short value to print
;

printShort_ANSI_UART:
000000ea	A0408000	push	r8
000000eb	A0409000	push	r9
000000ec	A040A000	push	r10
000000ed	A0408000	push	r8				; temporarily save r8
000000ee	42800030	lix		r8,0x30
000000ef	D4FFFF9D	bsr		write_ANSI_UART
000000f0	42800078	lix		r8,0x78
000000f1	D4FFFF9B	bsr		write_ANSI_UART
000000f2	A1804000	pull	r8				; restore r8
000000f3	42900004	lix		r9,4			; loop counter
000000f4	31808000	sl8		r8,r8
000000f5	31808000	sl8		r8,r8
doNextprintShortANSI_UART:
000000f6	34808000	rol1	r8,r8
000000f7	34808000	rol1	r8,r8
000000f8	34808000	rol1	r8,r8
000000f9	34808000	rol1	r8,r8
000000fa	D4FFFFCF	bsr		printHexVal_ANSI_UART
000000fb	23990001	subi	r9,r9,1
000000fc	C7FFFFFA	bnz		doNextprintShortANSI_UART
000000fd	A1A04000	pull	r10
000000fe	A1904000	pull	r9
000000ff	A1804000	pull	r8
00000100	A1704000	pull	PC

;
; printLong_ANSI_UART
; r8 contains the long value to print
;

printLong_ANSI_UART:
00000101	A0408000	push	r8
00000102	A0409000	push	r9
00000103	A040A000	push	r10
00000104	A0408000	push	r8				; temporarily save r8
00000105	42800030	lix		r8,0x30
00000106	D4FFFF86	bsr		write_ANSI_UART
00000107	42800078	lix		r8,0x78
00000108	D4FFFF84	bsr		write_ANSI_UART
00000109	A1804000	pull	r8				; restore r8
0000010a	42900008	lix		r9,8			; loop counter
doNextprintLongANSI_UART:
0000010b	34808000	rol1	r8,r8
0000010c	34808000	rol1	r8,r8
0000010d	34808000	rol1	r8,r8
0000010e	34808000	rol1	r8,r8
0000010f	D4FFFFBA	bsr		printHexVal_ANSI_UART
00000110	23990001	subi	r9,r9,1
00000111	C7FFFFFA	bnz		doNextprintLongANSI_UART
00000112	A1A04000	pull	r10
00000113	A1904000	pull	r9
00000114	A1804000	pull	r8
00000115	A1704000	pull	PC

; putChar_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

putChar_ANSI_UART:
00000116	D4000057	bsr		putChar_ANSI
00000117	D4FFFF3D	bsr		putChar_UART
00000118	A1704000	pull	PC
;--------------------------------------------------------------------
; timers.asm

; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
00000119	A0409000	push	r9
0000011a	42503802	lix		PAR,0x3802		; address of the mSec counter
0000011b	84905000	lpl		r9				; read the peripheral counter into r9
0000011c	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
0000011d	84905000	lpl		r9				; check the elapsed time counter
0000011e	38389000	cmp		r8,r9
0000011f	CCFFFFFE	blt		loop_delay_mS
00000120	A1904000	pull	r9
00000121	A1704000	pull	PC

;
; delay_uS - delay for the number of uSecs
; pass mSec delay in r8
; Uses routine uses r9 (saved and restored)
;

delay_uS:
00000122	A0409000	push	r9
00000123	A0405000	push	PAR
00000124	42503801	lix		PAR,0x3801		; address of the uSec counter
00000125	84905000	lpl		r9				; read the peripheral counter into r9
00000126	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_uS:
00000127	84905000	lpl		r9				; check the elapsed time counter
00000128	38389000	cmp		r8,r9
00000129	CCFFFFFE	blt		loop_delay_uS
0000012a	A1504000	pull	PAR
0000012b	A1904000	pull	r9
0000012c	A1704000	pull	PC

;--------------------------------------------------------------------
; SevenSegLEDs.asm

; wr7Seg8Dig
; passed r8 - value to send to the 7 seg display

wr7Seg8Dig:
0000012d	A0405000	push	PAR
0000012e	A0408000	push	r8
0000012f	42503000	lix		PAR,0x3000		; Seven Segment LED lines
00000130	85508000	spl		r8				; Write out LED bits
00000131	A1804000	pull	r8
00000132	A1504000	pull	PAR
00000133	A1704000	pull	PC

;
; hexToSevenSeg - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg:
00000134	A0409000	push	r9
00000135	A0406000	push	DAR
00000136	A0405000	push	PAR
00000137	42900000	lix		r9,0
00000138	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
00000139	68806000	ldbp	r8
0000013a	D4FFFF55	bsr		asciiToHex_ANSI_UART
0000013b	2B88000F	andi	r8,r8,0xf
0000013c	28998000	or		r9,r9,r8
0000013d	30909000	sl1		r9,r9
0000013e	30909000	sl1		r9,r9
0000013f	30909000	sl1		r9,r9
00000140	30909000	sl1		r9,r9
00000141	60806000	ldb		r8
00000142	D4FFFF4D	bsr		asciiToHex_ANSI_UART
00000143	2B88000F	andi	r8,r8,0xf
00000144	28998000	or		r9,r9,r8
00000145	42503000	lix		PAR,0x3000		; seven segment display
00000146	85509000	spl		r9
00000147	20890000	add		r8,r9,ZERO
00000148	A1504000	pull	PAR
00000149	A1604000	pull	DAR
0000014a	A1904000	pull	r9
0000014b	A1704000	pull	PC

;--------------------------------------------------------------------
; buzzer.asm

;
; makeBuzz - Make the buzzer buzz
;

makeBuzz:
0000014c	A0408000	push	r8
0000014d	42800000	lix		r8,0			; first note is 0
0000014e	D400001A	bsr 	setNote
0000014f	D4000006	bsr		enableBuzzer
00000150	428000FA	lix		r8,250			; count for 1 Sec
00000151	D4FFFFC8	bsr		delay_mS		; call delay_ms
00000152	D400000C	bsr		disableBuzzer
00000153	A1804000	pull	r8
00000154	A1704000	pull	PC
;
; enableBuzzer
;

enableBuzzer:
00000155	A0408000	push	r8
00000156	A0405000	push	PAR
00000157	42502800	lix		PAR,0x2800
00000158	84805000	lpl		r8
00000159	29880010	ori		r8,r8,0x10
0000015a	85508000	spl		r8
0000015b	A1504000	pull	PAR
0000015c	A1804000	pull	r8
0000015d	A1704000	pull	PC

;
; disableBuzzer
;

disableBuzzer:
0000015e	A0408000	push	r8
0000015f	A0405000	push	PAR
00000160	4290FFEF	lix		r9,0xffef		; Buzzer Disable line
00000161	42502800	lix		PAR,0x2800
00000162	84805000	lpl		r8
00000163	2B88FFEF	andi	r8,r8,0xffef
00000164	85508000	spl		r8
00000165	A1504000	pull	PAR
00000166	A1804000	pull	r8
00000167	A1704000	pull	PC

;--------------------------------------------------------------------
; music.asm

;
; setNote - Set the note
; pass note in r8
; returns note
;

setNote:
00000168	A0405000	push	PAR
00000169	42504000	lix		PAR,0x4000
0000016a	85508000	spl		r8
0000016b	A1504000	pull	PAR
0000016c	A1704000	pull	PC
;--------------------------------------------------------------------
; ANSIScreen.asm

;
; putChar_ANSI - Put a character to the screen
; Character to put to screen is in r8
;

putChar_ANSI:
0000016d	A0409000	push	r9
0000016e	A0405000	push	PAR
0000016f	42500000	lix		PAR,0x0		; UART Status
waitScreenTxStat:
00000170	84905000	lpl		r9			; Read Status into r9
00000171	2B990002	andi	r9,r9,0x2
00000172	C3FFFFFE	bez 	waitScreenTxStat
00000173	42500001	lix 	PAR,0x1
00000174	85508000	spl		r8			; echo the character
00000175	A1504000	pull	PAR
00000176	A1904000	pull	r9
00000177	A1704000	pull	PC

;
; printANSICode - Send the ANSI Escape Sequence
; printCode_ANSI - Send the ANSI Escape Sequence
; r8 - points to the string
; This routine supplies the ESC
;

printANSICode:
printCode_ANSI:
00000178	A0408000	push	r8
00000179	A0408000	push	r8
0000017a	4280001B	lix		r8,0x1b			; ESC
0000017b	D4FFFFF2	bsr		putChar_ANSI
0000017c	A1804000	pull	r8
0000017d	D400000A	bsr		printString_ANSI
0000017e	A1804000	pull	r8
0000017f	A1704000	pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
00000180	A0408000	push	r8
00000181	4280000A	lix		r8,0x0A				; Line Feed
00000182	D4FFFFEB	bsr		putChar_ANSI	; Put the character to the screen
00000183	4280000D	lix		r8,0x0D				; Carriage Return
00000184	D4FFFFE9	bsr		putChar_ANSI	; Echo character back to the UART
00000185	A1804000	pull	r8
00000186	A1704000	pull	PC

;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
00000187	A0408000	push	r8					; save r8
00000188	A0406000	push	DAR
00000189	20680000	add		DAR,r8,ZERO			; set the start of the string
nextCharANSI:
0000018a	68806000	ldbp	r8					; get the character01
0000018b	39380000	cmpi	r8,0x0				; Null terminated string
0000018c	D1000003	beq		donePrANSIStr		; done if null
0000018d	D4FFFFE0	bsr		putChar_ANSI	; write out the character
0000018e	C0FFFFFC	bra		nextCharANSI
donePrANSIStr:
0000018f	A1604000	pull	DAR					; restore DAR
00000190	A1804000	pull	r8					; restore r8
00000191	A1704000	pull	PC					; rts

;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
00000192	A0408000	push	r8
00000193	A0409000	push	r9
00000194	A0408000	push	r8				; temporarily save r8
00000195	A1804000	pull	r8				; restore r8
00000196	42900002	lix		r9,2			; loop counter
00000197	31808000	sl8		r8,r8
00000198	31808000	sl8		r8,r8
00000199	31808000	sl8		r8,r8
doNextprintByte_ANSI:
0000019a	34808000	rol1	r8,r8
0000019b	34808000	rol1	r8,r8
0000019c	34808000	rol1	r8,r8
0000019d	34808000	rol1	r8,r8
0000019e	D4000006	bsr		printHexVal_ANSI
0000019f	23990001	subi	r9,r9,1
000001a0	C7FFFFFA	bnz		doNextprintByte_ANSI
000001a1	A1904000	pull	r9
000001a2	A1804000	pull	r8
000001a3	A1704000	pull	PC

;
; printHexValANSI
;

printHexVal_ANSI:
000001a4	A0408000	push	r8
000001a5	2B88000F	andi	r8,r8,0xf
000001a6	39380009	cmpi	r8,9
000001a7	CC000004	blt		printHexLetterANSI
000001a8	21880030	addi	r8,r8,0x30
000001a9	D4FFFFC4	bsr		putChar_ANSI
000001aa	C0000003	bra		donePrintHexValANSI
printHexLetterANSI:
000001ab	21880037	addi	r8,r8,0x37		; 'A' - 10
000001ac	D4FFFFC1	bsr		putChar_ANSI
donePrintHexValANSI:
000001ad	A1804000	pull	r8
000001ae	A1704000	pull	PC

;
; clearScreen_ANSI - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
; No passed value
; Uses r8 (saved during function)
; no return value
;

clearScreen_ANSI:
000001af	A0408000	push	r8				; save r8
000001b0	4280001B	lix		r8,0x1b			; ESC
000001b1	D4FFFFBC	bsr		putChar_ANSI
000001b2	4280005B	lix		r8,0x5b			; [
000001b3	D4FFFFBA	bsr		putChar_ANSI
000001b4	42800032	lix		r8,0x32			; 2
000001b5	D4FFFFB8	bsr		putChar_ANSI
000001b6	4280004A	lix		r8,0x4A			; J
000001b7	D4FFFFB6	bsr		putChar_ANSI
000001b8	A1804000	pull	r8
000001b9	A1704000	pull	PC				; rts

;
; printLong_ANSI
; r8 contains the long value to print
;

printLong_ANSI:
000001ba	A0408000	push	r8
000001bb	A0409000	push	r9
000001bc	A0408000	push	r8				; temporarily save r8
000001bd	42800030	lix		r8,0x30			; print 0x
000001be	D4FFFFAF	bsr		putChar_ANSI
000001bf	42800078	lix		r8,0x78
000001c0	D4FFFFAD	bsr		putChar_ANSI
000001c1	A1804000	pull	r8				; restore r8
000001c2	42900008	lix		r9,8			; loop counter
doNextprintLong_ANSI:
000001c3	34808000	rol1	r8,r8
000001c4	34808000	rol1	r8,r8
000001c5	34808000	rol1	r8,r8
000001c6	34808000	rol1	r8,r8
000001c7	D4FFFFDD	bsr		printHexVal_ANSI
000001c8	23990001	subi	r9,r9,1
000001c9	C7FFFFFA	bnz		doNextprintLong_ANSI
000001ca	A1904000	pull	r9
000001cb	A1804000	pull	r8
000001cc	A1704000	pull	PC
