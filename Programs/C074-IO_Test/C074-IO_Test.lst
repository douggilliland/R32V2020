;
; C074-IO_Test - Read a line from the UART serial input
; Echo line to the serial port and to the screen
; Parse the line
;

prompt:			.string "R32V2020> "
; lineBuff is 80 characters long
lineBuff:		.string "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
syntaxError:	.string "Syntax error"
runningString:	.string "Running..."
hitAnyKey:		.string "Hit any key to exit..."
menuItem_01:	.string "01-Ring LED Test      "
menuItem_02:	.string "02-7 Segment LED Test "
menuItem_03:	.string "03-Pushbutton Test    "
menuItem_04:	.string "04-DIP Switch Test    "
menuItem_05:	.string "05-ANSI Screen Test   "
menuItem_06:	.string "06-Serial Port Test   "
menuItem_07:	.string "07-MCP23008 I2C Test  "
menuItem_08:	.string "08-MCP4231 SPI Test   "
menuItem_09:	.string "09-PS/2 Keyboard Test "
menuItem_10:	.string "10-Buzzer Test        "
menuItem_11:	.string "11-TBD Test        "

;
; Read a line from the UART and parse the line
;

main:
00000000	D4000246		bsr		clearScreen
00000001	D4000004		bsr		printMenu
00000002	D400001C		bsr		getLine
00000003	D4000041		bsr		parseLine
00000004	C0FFFFFC		bra		main

;
; printMenu - Print the menu
;

printMenu:
00000005	A0408000		push	r8
00000006	42800094		lix		r8,menuItem_01.lower
00000007	D4000220		bsr		printString
00000008	428000AC		lix		r8,menuItem_02.lower
00000009	D400021E		bsr		printString
0000000a	428000C4		lix		r8,menuItem_03.lower
0000000b	D4000227		bsr		printLine
0000000c	428000DC		lix		r8,menuItem_04.lower
0000000d	D400021A		bsr		printString
0000000e	428000F4		lix		r8,menuItem_05.lower
0000000f	D4000218		bsr		printString
00000010	4280010C		lix		r8,menuItem_06.lower
00000011	D4000221		bsr		printLine
00000012	42800124		lix		r8,menuItem_07.lower
00000013	D4000214		bsr		printString
00000014	4280013C		lix		r8,menuItem_08.lower
00000015	D4000212		bsr		printString
00000016	42800154		lix		r8,menuItem_09.lower
00000017	D400021B		bsr		printLine
00000018	4280016C		lix		r8,menuItem_10.lower
00000019	D4000219		bsr		printLine
0000001a	42800000		lix		r8,prompt.lower
0000001b	D400020C		bsr		printString
0000001c	A1804000		pull	r8
0000001d	A1704000		pull	PC

;
; getLine - Reads the UART and fills a buffer with the characters received
; r8 received character - Character received from the UART
; r9 is constant - ENTER key on keyboard
; r10 is the input buffer length
; r11 is the BACK key on keyboard
; r12 used to test the backspace doesn't go past the start of the buffer
; DAR points to lineBuff current character position
;

getLine:
0000001e	A0408000		push	r8
0000001f	A0409000		push	r9
00000020	A040A000		push	r10
00000021	A040B000		push	r11
00000022	A040C000		push	r12
00000023	A0406000		push	DAR
00000024	4260000C		lix		DAR,lineBuff.lower	; DAR pointer = start of line buffer
00000025	42B0007F		lix		r11,0x7F			; BACK key - rubout
00000026	42A0004F		lix		r10,79				; number of chars in the line buffer
00000027	4290000D		lix		r9,0x0D				; ENTER key - ends the line
loopReadLine:
00000028	D40001E8		bsr		waitGetCharFromUART	; Get a character from the UART
00000029	D400022C		bsr		putCharToANSIScreen	; Put the character to the screen
0000002a	D40001EF		bsr		putCharToUART		; Echo character back to the UART
0000002b	30389000		cmp		r8,r9				; check if received char was end of line
0000002c	D1000006		beq		gotEOL
0000002d	3038B000		cmp		r8,r11
0000002e	D1000009		beq		gotBackspace
0000002f	69608000		sdbp	r8
;	add		DAR,DAR,ONE			; increment to next long in buffer
00000030	20AA2000		add		r10,r10,MINUS1
00000031	C7FFFFF7		bnz		loopReadLine		; Next char would overflow
	; tbd add code for line too long	
gotEOL:
00000032	4280000A		lix		r8,0x0A				; Echo line feed after CR
00000033	D4000222		bsr		putCharToANSIScreen	; Put the character to the screen
00000034	D40001E5		bsr		putCharToUART		; Echo character back to the UART
00000035	61600000		sdb		r0					; null at end of line read
00000036	C0000007		bra		doneHandlingLine
gotBackspace:
00000037	20662000		add		DAR,DAR,MINUS1
00000038	42C0000C		lix		r12,lineBuff.lower	; r12 pointer = start of line buffer
00000039	303C6000		cmp		r12,DAR
0000003a	CFFFFFEE		bgt		loopReadLine
0000003b	206C0000		add		DAR,r12,r0
0000003c	C0FFFFEC		bra		loopReadLine
doneHandlingLine:
0000003d	A1604000		pull	DAR
0000003e	A1C04000		pull	r12
0000003f	A1B04000		pull	r11
00000040	A1A04000		pull	r10
00000041	A1904000		pull	r9
00000042	A1804000		pull	r8
00000043	A1704000		pull	PC

;
; parseLine - 
; line is in lineBuff
;

parseLine:
00000044	A0408000		push	r8
00000045	A0409000		push	r9
00000046	A0406000		push	DAR
00000047	4280000C		lix		r8,lineBuff.lower
00000048	D4000185		bsr		hexToSevenSeg
; Check to see if the command is 0x01
00000049	42900001		lix		r9,0x01
0000004a	30389000		cmp		r8,r9
0000004b	D2000003		bne		skipTo2
0000004c	D4000039		bsr		testRoutine1
0000004d	C0000032		bra		doneTests
; Check to see if the command is 0x02
skipTo2:
0000004e	42900002		lix		r9,0x02
0000004f	30389000		cmp		r8,r9
00000050	D2000003		bne		skipTo3
00000051	D4000050		bsr		testRoutine2
00000052	C000002D		bra		doneTests
; Check to see if the command is 0x03
skipTo3:
00000053	42900003		lix		r9,0x03
00000054	30389000		cmp		r8,r9
00000055	D2000003		bne		skipTo4
00000056	D4000065		bsr		testRoutine3
00000057	C0000028		bra		doneTests
; Check to see if the command is 0x04
skipTo4:
00000058	42900004		lix		r9,0x04
00000059	30389000		cmp		r8,r9
0000005a	D2000003		bne		skipTo5
0000005b	D4000082		bsr		testRoutine4
0000005c	C0000023		bra		doneTests
; Check to see if the command is 0x05
skipTo5:
0000005d	42900005		lix		r9,0x05
0000005e	30389000		cmp		r8,r9
0000005f	D2000003		bne		skipTo6
00000060	D4000091		bsr		testRoutine5
00000061	C000001E		bra		doneTests
; Check to see if the command is 0x06
skipTo6:
00000062	42900006		lix		r9,0x06
00000063	30389000		cmp		r8,r9
00000064	D2000003		bne		skipTo7
00000065	D400009B		bsr		testRoutine6
00000066	C0000019		bra		doneTests
; Check to see if the command is 0x07
skipTo7:
00000067	42900007		lix		r9,0x07
00000068	30389000		cmp		r8,r9
00000069	D2000003		bne		skipTo8
0000006a	D40000A5		bsr		testRoutine7
0000006b	C0000014		bra		doneTests
; Check to see if the command is 0x08
skipTo8:
0000006c	42900008		lix		r9,0x08
0000006d	30389000		cmp		r8,r9
0000006e	D2000003		bne		skipTo9
0000006f	D4000114		bsr		testRoutine8
00000070	C000000F		bra		doneTests
; Check to see if the command is 0x09
skipTo9:
00000071	42900009		lix		r9,0x09
00000072	30389000		cmp		r8,r9
00000073	D2000003		bne		skipTo10
00000074	D4000137		bsr		testRoutine9
00000075	C000000A		bra		doneTests
; Check to see if the command is 0x10
skipTo10:
00000076	42900010		lix		r9,0x10
00000077	30389000		cmp		r8,r9
00000078	D2000003		bne		skipTo11
00000079	D4000140		bsr		testRoutine10
0000007a	C0000005		bra		doneTests
;
skipTo11:
0000007b	A0408000		push	r8
0000007c	42800060		lix		r8,syntaxError.lower
0000007d	D40001AA		bsr		printString
0000007e	A1804000		pull	r8
doneTests:
0000007f	428007D0		lix		r8,2000
00000080	D400020B		bsr		delay_mS
00000081	A1604000		pull	DAR
00000082	A1904000		pull	r9
00000083	A1804000		pull	r8
00000084	A1704000		pull	PC
	
;
; Test Ring LEDs
;

testRoutine1:
00000085	A0408000		push	r8
00000086	A0409000		push	r9
00000087	42800070		lix		r8,runningString.lower
00000088	D400019F		bsr		printString
00000089	42800094		lix		r8,menuItem_01.lower
0000008a	D40001A8		bsr		printLine
0000008b	42901000		lix		r9,0x1000			; ring has been circled
reload:
0000008c	42800001		lix		r8,1
loopLEDRing:
0000008d	D400000D		bsr		putValueToRingLEDs	; put the switches to the 7 Segment LED
0000008e	A0408000		push	r8
0000008f	428000FA		lix		r8,250				; wait for 1 second
00000090	D40001FB		bsr		delay_mS
00000091	A1804000		pull	r8
00000092	25808000		sl1		r8,r8
00000093	30389000		cmp		r8,r9
00000094	D2FFFFF9		bne		loopLEDRing
	;bra		reload
00000095	42800000		lix		r8,0
00000096	D4000004		bsr		putValueToRingLEDs	; put the switches to the 7 Segment LED
00000097	A1904000		pull	r9
00000098	A1804000		pull	r8
00000099	A1704000		pull	PC
	
; putValueToRingLEDs
; passed r8 - value to send to the ring LEDs

putValueToRingLEDs:
0000009a	A0405000		push	PAR
0000009b	A0408000		push	r8
0000009c	42504800		lix		PAR,0x4800		; Ring LED address
0000009d	85508000		spl		r8				; Write out LED bits
0000009e	A1804000		pull	r8
0000009f	A1504000		pull	PAR
000000a0	A1704000		pull	PC

;
; Seven Segment Display Test
;

testRoutine2:
000000a1	A0408000		push	r8
000000a2	42800070		lix		r8,runningString.lower
000000a3	D4000184		bsr		printString
000000a4	428000AC		lix		r8,menuItem_02.lower
000000a5	D400018D		bsr		printLine
000000a6	41801234		liu		r8,0x1234
000000a7	40805678		lil		r8,0x5678
000000a8	D400000C		bsr		wr7Seg8Dig
000000a9	428007D0		lix		r8,2000
000000aa	D40001E1		bsr		delay_mS
000000ab	4180ABCD		liu		r8,0xABCD
000000ac	4080EF12		lil		r8,0xEF12
000000ad	D4000007		bsr		wr7Seg8Dig
000000ae	428007D0		lix		r8,2000
000000af	D40001DC		bsr		delay_mS
000000b0	42800000		lix		r8,0x0
000000b1	D4000003		bsr		wr7Seg8Dig
000000b2	A1804000		pull	r8
000000b3	A1704000		pull	PC
	
; wr7Seg8Dig
; passed r8 - value to send to the 7 seg display

wr7Seg8Dig:
000000b4	A0405000		push	PAR
000000b5	A0408000		push	r8
000000b6	42503000		lix		PAR,0x3000		; Seven Segment LED lines
000000b7	85508000		spl		r8				; Write out LED bits
000000b8	A1804000		pull	r8
000000b9	A1504000		pull	PAR
000000ba	A1704000		pull	PC
	
;
; Pushbutton Test
;

testRoutine3:
000000bb	A0408000		push	r8
000000bc	A0409000		push	r9
000000bd	A040A000		push	r10
000000be	42800070		lix		r8,runningString.lower
000000bf	D4000168		bsr		printString
000000c0	428000C4		lix		r8,menuItem_03.lower
000000c1	D4000171		bsr		printLine
000000c2	42A00000		lix		r10,0x0
loopSwRead:
000000c3	D4000011		bsr		readSws		; returns switches and pushbuttons in r8
000000c4	42900007		lix		r9,0x7
000000c5	23889000		and		r8,r8,r9
000000c6	42900030		lix		r9,0x30
000000c7	20889000		add		r8,r8,r9
000000c8	3038A000		cmp		r8,r10
000000c9	D1FFFFFA		beq		loopSwRead
000000ca	20A80000		add		r10,r8,r0
000000cb	D400018A		bsr		putCharToANSIScreen
000000cc	D4000172		bsr		newLine
000000cd	428000FA		lix		r8,250
000000ce	D40001BD		bsr		delay_mS
000000cf	C0FFFFF4		bra		loopSwRead
000000d0	A1A04000		pull	r10
000000d1	A1904000		pull	r9
000000d2	A1804000		pull	r8
000000d3	A1704000		pull	PC
	
;
; readSws
; switches value returned in r8
; switches are high when pressed
; Switches d0-d2 are the pushbutton switches (inverted)
; 	Pushbutton switches are debounced
; Switches d3-10 are the DIP switches (not inverted)
;

readSws:
000000d4	A0405000		push	PAR
000000d5	A0409000		push	r9
000000d6	42900007		lix		r9,0x7
000000d7	42502000		lix		PAR,0x2000	; Switches address
000000d8	84805000		lpl		r8			; Read switches into r9
000000d9	24889000		xor		r8,r8,r9
000000da	A1904000		pull	r9
000000db	A1504000		pull	PAR
000000dc	A1704000		pull	PC
	
;
; DIP Switch Test
;

testRoutine4:
000000dd	42800070		lix		r8,runningString.lower
000000de	D4000149		bsr		printString
000000df	428000DC		lix		r8,menuItem_04.lower
000000e0	D4000152		bsr		printLine
000000e1	42A00000		lix		r10,0x0
loopSwRead2:
000000e2	D4FFFFF2		bsr		readSws		; returns switches and pushbuttons in r8
000000e3	27808000		sr1		r8,r8
000000e4	27808000		sr1		r8,r8
000000e5	27808000		sr1		r8,r8
000000e6	27808000		sr1		r8,r8
000000e7	429000FF		lix		r9,0xff
000000e8	23889000		and		r8,r8,r9
000000e9	3038A000		cmp		r8,r10
000000ea	D1FFFFF8		beq		loopSwRead2
000000eb	20A80000		add		r10,r8,r0
000000ec	D4FFFFC8		bsr		wr7Seg8Dig
;	bsr		newLine
000000ed	428000FA		lix		r8,250
000000ee	D400019D		bsr		delay_mS
000000ef	C0FFFFF3		bra		loopSwRead2
000000f0	A1704000		pull	PC
	
;
; ANSI Screen Test
;

testRoutine5:
000000f1	A0408000		push	r8
000000f2	A0409000		push	r9
000000f3	42800070		lix		r8,runningString.lower
000000f4	D4000133		bsr		printString
000000f5	428000F4		lix		r8,menuItem_05.lower
000000f6	D400013C		bsr		printLine
000000f7	429000FF		lix		r9,0xff		; end with backspace
000000f8	42800020		lix		r8,0x20			; start with a space
anotherCharT5:
000000f9	D400015C		bsr		putCharToANSIScreen
000000fa	20881000		add		r8,r8,ONE
000000fb	30389000		cmp		r8,r9
000000fc	D2FFFFFD		bne		anotherCharT5
000000fd	A1904000		pull	r9
000000fe	A1804000		pull	r8
000000ff	A1704000		pull	PC
	
;
; Serial Port Test
;

testRoutine6:
00000100	A0408000		push	r8
00000101	A0409000		push	r9
00000102	42800070		lix		r8,runningString.lower
00000103	D4000124		bsr		printString
00000104	4280010C		lix		r8,menuItem_06.lower
00000105	D400012D		bsr		printLine
00000106	4290007F		lix		r9,0x7f			; end with backspace
00000107	42800020		lix		r8,0x20			; start with a space
anotherCharT6:
00000108	D4000111		bsr		putCharToUART
00000109	20881000		add		r8,r8,ONE
0000010a	30389000		cmp		r8,r9
0000010b	D2FFFFFD		bne		anotherCharT6
0000010c	A1904000		pull	r9
0000010d	A1804000		pull	r8
0000010e	A1704000		pull	PC
	
;
; MCP23008 I2C Test
;

testRoutine7:
0000010f	42800070		lix		r8,runningString.lower
00000110	D4000117		bsr		printString
00000111	42800124		lix		r8,menuItem_07.lower
00000112	D4000120		bsr		printLine
; Code to initialize I2CIO8 card
00000113	D4000016		bsr		init_Regs_I2CIO8	; initialize the MCP23008 on the I2CIO8
restartLoop:
00000114	42800008		lix		r8,0x08
loopMain:
00000115	D400002F		bsr		wrI2CAdrDat_MCP23008	; write to LEDs
00000116	D4000006		bsr		delayFromJumpers
00000117	27808000		sr1		r8,r8					; shift LED bit right by 1
00000118	30380000		cmp		r8,r0
00000119	D2FFFFFC		bne		loopMain
0000011a	C0FFFFFA		bra		restartLoop				; restart the shifting
0000011b	A1704000		pull	PC
	
;
; delayFromJumpers - Set delay based on header value
; returns: nothing (restores registers at return)
;

delayFromJumpers:
0000011c	A0409000		push	r9
0000011d	A0408000		push	r8
0000011e	D4000034	 	bsr		readI2CDat_MCP23008		; read headers into r8
0000011f	24882000		xor		r8,r8,MINUS1			; invert headers
00000120	429000F0		lix		r9,0xF0
00000121	23889000		and		r8,r8,r9				; keep 8 bits
00000122	25808000		sl1		r8,r8
00000123	25808000		sl1		r8,r8
00000124	25808000		sl1		r8,r8
00000125	D4000166		bsr		delay_mS
00000126	A1804000		pull	r8
00000127	A1904000		pull	r9
00000128	A1704000		pull	PC

;
; init_Regs_I2CIO8 - Set IO Dir
;

init_Regs_I2CIO8:
00000129	A0408000		push	r8
	; Write 0x22 to IOCON register (not sequential operations)
0000012a	42800001		lix		r8,0x01		; I2C_Ctrl = START
0000012b	D400004A		bsr		write_I2C_Ctrl_Reg
0000012c	42800040		lix		r8,0x40		; I2C write command at slave address = 0x20
0000012d	D4000039		bsr		write_I2C_Data_Address_Reg
0000012e	42800000		lix		r8,0x00		; I2C_Ctrl = IDLE
0000012f	D4000046		bsr		write_I2C_Ctrl_Reg
00000130	42800005		lix		r8,0x05		; MCP23008 IOCON
00000131	D4000035		bsr		write_I2C_Data_Address_Reg
00000132	42800003		lix		r8,0x03		; I2C_Ctrl = STOP
00000133	D4000042		bsr		write_I2C_Ctrl_Reg	
00000134	42800022		lix		r8,0x22		; SEQOP = Disabled, INTPOL = Active-high
00000135	D4000031		bsr		write_I2C_Data_Address_Reg
	; Write 0xF0 to Direction Control register
00000136	42800001		lix		r8,0x01		; I2C_Ctrl = START
00000137	D400003E		bsr		write_I2C_Ctrl_Reg
00000138	42800040		lix		r8,0x40		; I2C write command at slave address = 0x20
00000139	D400002D		bsr		write_I2C_Data_Address_Reg
0000013a	42800000		lix		r8,0x00		; I2C_Ctrl = IDLE
0000013b	D400003A		bsr		write_I2C_Ctrl_Reg
0000013c	42800000		lix		r8,0x00		; MCP23008 IODIR
0000013d	D4000029		bsr		write_I2C_Data_Address_Reg
0000013e	42800003		lix		r8,0x03		; I2C_Ctrl = STOP
0000013f	D4000036		bsr		write_I2C_Ctrl_Reg
00000140	428000F0		lix		r8,0xF0		; Input and output bits
00000141	D4000025		bsr		write_I2C_Data_Address_Reg
00000142	A1804000		pull	r8
00000143	A1704000		pull	PC

;
; wrI2CAdrDat_MCP23008 - Write address to the I2C bus
; Address 0x5800 -> DATA (write/read) or SLAVE ADDRESS (write)  
; Address 0x5801 -> Command/Status Register (write/read)
; r8 is the value to write
;

wrI2CAdrDat_MCP23008:
00000144	A0408000		push	r8
00000145	42800001		lix		r8,0x01		; I2C_Ctrl = START
00000146	D400002F		bsr		write_I2C_Ctrl_Reg
00000147	42800040		lix		r8,0x40		; I2C write command at slave address = 0x20
00000148	D400001E		bsr		write_I2C_Data_Address_Reg
00000149	42800000		lix		r8,0x00		; I2C_Ctrl = IDLE
0000014a	D400002B		bsr		write_I2C_Ctrl_Reg	
0000014b	4280000A		lix		r8,0x0A		; MCP23008 OLAT
0000014c	D400001A		bsr		write_I2C_Data_Address_Reg
0000014d	42800003		lix		r8,0x03		; I2C_Ctrl = STOP
0000014e	D4000027		bsr		write_I2C_Ctrl_Reg	
0000014f	A1804000		pull	r8			; Data to write is in r8
00000150	D4000016		bsr		write_I2C_Data_Address_Reg
00000151	A1704000		pull	PC
	
;
; readI2CDat_MCP23008 - Read data from the I2C bus
; Address 0x5800 -> DATA (write/read) or SLAVE ADDRESS (write)  
; Address 0x5801 -> Command/Status Register (write/read)
; r8 is the value to write
;

readI2CDat_MCP23008:
	; write the GPIO address register
00000152	42800001		lix		r8,0x01		; I2C_Ctrl = START
00000153	D4000022		bsr		write_I2C_Ctrl_Reg
00000154	42800040		lix		r8,0x40		; I2C write command at slave address = 0x20
00000155	D4000011		bsr		write_I2C_Data_Address_Reg
00000156	42800003		lix		r8,0x03		; I2C_Ctrl = STOP
00000157	D400001E		bsr		write_I2C_Ctrl_Reg	
00000158	42800009		lix		r8,0x09		; MCP23008 - GPIO register address
00000159	D400000D		bsr		write_I2C_Data_Address_Reg
	; Read the GPIO line value
0000015a	42800001		lix		r8,0x01		; I2C_Ctrl = START
0000015b	D400001A		bsr		write_I2C_Ctrl_Reg
0000015c	42800041		lix		r8,0x41		; I2C read command at slave address = 0x20
0000015d	D4000009		bsr		write_I2C_Data_Address_Reg
0000015e	42800000		lix		r8,0x00		; I2C_Ctrl = IDLE
0000015f	D4000016		bsr		write_I2C_Ctrl_Reg	
00000160	D400000C		bsr		read_I2C_Data_Reg
00000161	A0408000		push	r8
00000162	42800003		lix		r8,0x03		; I2C_Ctrl = STOP
00000163	D4000012		bsr		write_I2C_Ctrl_Reg	
00000164	A1804000		pull	r8
00000165	A1704000		pull	PC
	
;
; write_I2C_Data_Address_Reg
;

write_I2C_Data_Address_Reg:
00000166	A0405000		push	PAR
00000167	42505800		lix		PAR,0x5800	; I2C Address/register
00000168	85508000		spl		r8			; Write control register
00000169	D4000011		bsr		i2c_ack
0000016a	A1504000		pull	PAR
0000016b	A1704000		pull	PC

;
; read_I2C_Data_Reg - Read I2C data into r8
;

read_I2C_Data_Reg:
0000016c	A0405000		push	PAR
0000016d	42505800		lix		PAR,0x5800	; I2C Data Address
0000016e	42800054		lix		r8,0x54
0000016f	85508000		spl		r8
00000170	D400000A		bsr		i2c_ack
00000171	42505800		lix		PAR,0x5800	; I2C Data Address
00000172	84805000		lpl		r8
00000173	A1504000		pull	PAR
00000174	A1704000		pull	PC
	
;
; write_I2C_Ctrl_Reg
; Command Register (write):
;	bit 7-2	= Reserved
;	bit 1-0	= 
;		00: IDLE
;		01: START
;		10: nSTART
;		11: STOP
;

write_I2C_Ctrl_Reg:
00000175	A0405000		push	PAR
00000176	42505801		lix		PAR,0x5801	; I2C Control register
00000177	85508000		spl		r8			; Write control register
00000178	A1504000		pull	PAR
00000179	A1704000		pull	PC

;
; i2c_ack - wait for transfer to complete
; Status Register (read):
;	bit 7-2	= Reserved
;	bit 1 	= ERROR 	(I2C transaction error)
;	bit 0 	= BUSY 	(I2C bus busy)
;

i2c_ack:
0000017a	A0405000		push	PAR
0000017b	A0408000		push	r8
0000017c	42505801		lix		PAR,0x5801	; Control register
i2c_ack_loop:
0000017d	84805000		lpl		r8
0000017e	23881000		and		r8,r8,r1	; busy bit is least significant bit
0000017f	C4FFFFFE		be1		i2c_ack_loop
00000180	A1804000		pull	r8
00000181	A1504000		pull	PAR
00000182	A1704000		pull	PC

;
; MCP4231 SPI Test
;

testRoutine8:
00000183	42800070		lix		r8,runningString.lower
00000184	D40000A3		bsr		printString
00000185	4280013C		lix		r8,menuItem_08.lower
00000186	D40000AC		bsr		printLine
; Write ramp output to SPI-POTX2
; x6000-x67FF (2KB)	- SPI Address Range
; x6000 - d0-d7 = Write value
; x6001 - d0 = Write Chip Select line
; x6002 - d0 = Busy flag
00000187	42900080		lix		r9,0x80				; loop terminal count
reloadr8:
00000188	42800000		lix		r8,0x00				; sent out low voltage from pot
loopForever:
00000189	D4000006		bsr		writeSPI0
0000018a	20881000		add		r8,r8,r1
0000018b	30389000		cmp		r8,r9
0000018c	D2FFFFFD		bne		loopForever
0000018d	C0FFFFFB		bra		reloadr8
0000018e	A1704000		pull	PC
	
;
; writeSPI0 - Write to the first SPI pot
; r8 contains the data to write out
; 16-bit command Fig 7-1 in the data sheet
;

writeSPI0:
0000018f	A0408000		push	r8
00000190	42800000		lix		r8,0x00			; start chip select
00000191	42506001		lix		PAR,0x6001		; Chip Select Address
00000192	85508000		spl		r8				; Turn on Chip Select
00000193	42800000		lix		r8,0x00			; register select - REG0
00000194	42506000		lix		PAR,0x6000		; Data address
00000195	85508000		spl		r8				; Store data to the SPI bus
00000196	D400000B		bsr		waitSPITxRdy	; Wait for Tx Ready
00000197	A1804000		pull	r8				; data to write
00000198	A0408000		push	r8
00000199	42506000		lix		PAR,0x6000		; data address
0000019a	85508000		spl		r8				; Store data to the SPI bus
0000019b	D4000006		bsr		waitSPITxRdy	; Wait for Tx Ready
0000019c	42800001		lix		r8,0x01			; end chip select
0000019d	42506001		lix		PAR,0x6001		; Chip select address
0000019e	85508000		spl		r8				; Turn off chip select
0000019f	A1804000		pull	r8
000001a0	A1704000		pull	PC				; return	

;
; waitSPITxRdy - wait for SPI transfer to be complete
; Don't write until the busy cycles high then low
; R32V2020 is much faster than the SPI interface
; Need to wait for the busy to get set and the cleared again
;

waitSPITxRdy:
000001a1	A0408000		push	r8			; save r8 since it's used by calling function(s)
000001a2	42506002		lix		PAR,0x6002	; SPI busy bit address
loopSPIRdy:				; wait until busy gets set
000001a3	84805000		lpl		r8			; load the busy bit
000001a4	30380000		cmp		r8,r0		; 0 = not yet set
000001a5	D1FFFFFE		beq		loopSPIRdy	; wait until busy is set
loopSPIRdy2:			; wait while busy is set
000001a6	84805000		lpl		r8			; load the busy bit
000001a7	30381000		cmp		r8,r1		; 1 = busy is set
000001a8	D1FFFFFE		beq		loopSPIRdy2	; still busy
000001a9	A1804000		pull	r8			; restore r8
000001aa	A1704000		pull	PC			; return

;
; PS/2 Keyboard Test
; 0x0D
;

testRoutine9:
000001ab	A0408000		push	r8
000001ac	A0409000		push	r9
000001ad	42800070		lix		r8,runningString.lower
000001ae	D4000079		bsr		printString
000001af	42800154		lix		r8,menuItem_09.lower
000001b0	D4000082		bsr		printLine
000001b1	4290000D		lix		r9,0x0D
loopForeverT9:
000001b2	D40000E2		bsr		getPS2Char
000001b3	D40000A2		bsr		putCharToANSIScreen
000001b4	30389000		cmp		r8,r9
000001b5	D2FFFFFD		bne		loopForeverT9
000001b6	A1904000		pull	r9
000001b7	A1804000		pull	r8
000001b8	A1704000		pull	PC

;
; Buzzer Test
;

testRoutine10:
000001b9	A0408000		push	r8
000001ba	42800070		lix		r8,runningString.lower
000001bb	D400006C		bsr		printString
000001bc	4280016C		lix		r8,menuItem_10.lower
000001bd	D4000075		bsr		printLine
000001be	D40000B5		bsr		enableBuzzer
000001bf	42800100		lix		r8,0x100
000001c0	D40000CB		bsr		delay_mS
000001c1	D40000BE		bsr		disableBuzzer
000001c2	A1804000		pull	r8
000001c3	A1704000		pull	PC
	
;
; TBD Test
;

testRoutine11:
000001c4	A0408000		push	r8
000001c5	A0409000		push	r9
000001c6	42800070		lix		r8,runningString.lower
000001c7	D4000060		bsr		printString
000001c8	42800184		lix		r8,menuItem_11.lower
000001c9	D4000069		bsr		printLine
	;
000001ca	A1904000		pull	r9
000001cb	A1804000		pull	r8
000001cc	A1704000		pull	PC
	
;
; hexToSevenSeg - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg:
000001cd	A0409000		push	r9
000001ce	A0406000		push	DAR
000001cf	A0405000		push	PAR
000001d0	42900000		lix		r9,0
000001d1	20680000		add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
000001d2	68806000		ldbp	r8
000001d3	D4000010		bsr		asciiToHex
000001d4	22998000		or		r9,r9,r8
000001d5	25909000		sl1		r9,r9
000001d6	25909000		sl1		r9,r9
000001d7	25909000		sl1		r9,r9
000001d8	25909000		sl1		r9,r9
	;add		DAR,DAR,ONE
000001d9	60806000		ldb		r8
000001da	D4000009		bsr		asciiToHex
000001db	22998000		or		r9,r9,r8
000001dc	42503000		lix		PAR,0x3000		; seven segment display
000001dd	85509000		spl		r9
000001de	20890000		add		r8,r9,ZERO
000001df	A1504000		pull	PAR
000001e0	A1604000		pull	DAR
000001e1	A1904000		pull	r9
000001e2	A1704000		pull	PC

;
; asciiToHex - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
; Result is returned in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
;

asciiToHex:
000001e3	A0409000		push	r9
000001e4	42900066		lix		r9,0x66		; check if letter is > 'f'
000001e5	30398000		cmp		r9,r8
000001e6	CF000025		bgt		a2h_Error
000001e7	42900030		lix		r9,0x30		; check if letter is < '0'
000001e8	30398000		cmp		r9,r8	
000001e9	CC000022		blt		a2h_Error
000001ea	4290003A		lix		r9,0x3A		; check if letter is between '0' and '9' inclusively
000001eb	30398000		cmp		r9,r8
000001ec	CC000011		blt		gotDigit
000001ed	42900041		lix		r9,0x41		; check if letter is between '9' and 'A' exclusively
000001ee	30398000		cmp		r9,r8
000001ef	CC00001C		blt		a2h_Error
000001f0	42900047		lix		r9,0x47		; check if letter is between 'A' and F' inclusively
000001f1	30398000		cmp		r9,r8
000001f2	CC000012		blt		gotUpperLetter
000001f3	42900061		lix		r9,0x61		; check if between 'F' and 'a' exclusively
000001f4	30398000		cmp		r9,r8
000001f5	CC000016		blt		a2h_Error
; Lower case letter
000001f6	42900057		lix		r9,0x57
000001f7	24992000		xor		r9,r9,MINUS1
000001f8	20991000		add		r9,r9,ONE
000001f9	20889000		add		r8,r8,r9
000001fa	4290000F		lix		r9,0x0F
000001fb	23889000		and		r8,r8,r9
000001fc	C0000012		bra		doneConvA2H
gotDigit:
000001fd	42900030		lix		r9,0x30
000001fe	24992000		xor		r9,r9,MINUS1
000001ff	20991000		add		r9,r9,ONE
00000200	20889000		add		r8,r8,r9
00000201	4290000F		lix		r9,0x0F
00000202	23889000		and		r8,r8,r9
00000203	C000000B		bra		doneConvA2H
gotUpperLetter:
00000204	42900037		lix		r9,0x37
00000205	24992000		xor		r9,r9,MINUS1
00000206	20991000		add		r9,r9,ONE
00000207	20889000		add		r8,r8,r9
00000208	4290000F		lix		r9,0x0F
00000209	23889000		and		r8,r8,r9
0000020a	C0000004		bra		doneConvA2H
a2h_Error:
0000020b	42800060		lix		r8,syntaxError.lower
0000020c	D400001B		bsr		printString
0000020d	4280DEAD		lix		r8,0xDEAD
doneConvA2H:
0000020e	A1904000		pull	r9
0000020f	A1704000		pull	PC

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
00000210	A0405000		push	PAR
00000211	42501800		lix		PAR,0x1800	; UART Status
waitUartRxStat:
00000212	84805000		lpl		r8			; Read Status into r8
00000213	23881000		and 	r8,r8,ONE
00000214	C3FFFFFE		bez 	waitUartRxStat
00000215	42501801		lix 	PAR,0x1801
00000216	84805000		lpl		r8
00000217	A1504000		pull	PAR
00000218	A1704000		pull	PC

;
; putCharToUART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putCharToUART:
00000219	A0409000		push	r9
0000021a	A0405000		push	PAR
0000021b	A040A000		push	r10
0000021c	42A00002		lix		r10,0x2
0000021d	42501800		lix		PAR,0x1800	; UART Status
waitUartTxStat:
0000021e	84905000		lpl		r9			; Read Status into r9
0000021f	2399A000		and 	r9,r9,r10
00000220	C3FFFFFE		bez 	waitUartTxStat
00000221	42501801		lix 	PAR,0x1801
00000222	85508000		spl		r8			; echo the character
00000223	A1A04000		pull	r10
00000224	A1504000		pull	PAR
00000225	A1904000		pull	r9
00000226	A1704000		pull	PC
	
;
; printString - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString:
00000227	A0408000		push	r8					; save r8
00000228	A0406000		push	DAR
00000229	20680000		add		DAR,r8,ZERO			; set the start of the string
nextChar:
0000022a	68806000		ldbp	r8					; get the character01
0000022b	30380000		cmp		r8,ZERO				; Null terminated string
0000022c	D1000003		beq		donePrStr			; done if null
0000022d	D4000028		bsr		putCharToANSIScreen	; write out the character
0000022e	C0FFFFFC		bra		nextChar
donePrStr:
0000022f	A1604000		pull	DAR					; restore DAR
00000230	A1804000		pull	r8					; restore r8
00000231	A1704000		pull	PC					; rts
	
;
; printLine - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLine:
00000232	A0408000		push	r8					; save r8
00000233	A0406000		push	DAR
00000234	20680000		add		DAR,r8,ZERO			; set the start of the string
nextChar2:
00000235	68806000		ldbp		r8					; get the character
00000236	30380000		cmp		r8,ZERO				; Null terminated string
00000237	D1000003		beq		donePrStr2			; done if null
00000238	D400001D		bsr		putCharToANSIScreen	; write out the character
	;add		DAR,DAR,r1			; Point to next character
00000239	C0FFFFFC		bra		nextChar2
donePrStr2:
0000023a	D4000004		bsr		newLine
0000023b	A1604000		pull	DAR					; restore DAR
0000023c	A1804000		pull	r8					; restore r8
0000023d	A1704000		pull	PC					; rts
	
;
; newLine - Print out a newline (CR-LF)
;

newLine:
0000023e	A0408000		push	r8
0000023f	4280000A		lix		r8,0x0A				; Line Feed
00000240	D4000015		bsr		putCharToANSIScreen	; Put the character to the screen
00000241	4280000D		lix		r8,0x0D				; Carriage Return
00000242	D4000013		bsr		putCharToANSIScreen	; Put the character to the screen
00000243	D4FFFFD6		bsr		putCharToUART		; Echo character back to the UART
00000244	A1804000		pull	r8
00000245	A1704000		pull	PC

;
; clearScreen - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen:
00000246	A0408000		push	r8				; save r8
00000247	4280001B		lix		r8,0x1b			; ESC
00000248	D400000D		bsr		putCharToANSIScreen
00000249	D4FFFFD0		bsr		putCharToUART
0000024a	4280005B		lix		r8,0x5b			; [
0000024b	D400000A		bsr		putCharToANSIScreen
0000024c	D4FFFFCD		bsr		putCharToUART
0000024d	42800032		lix		r8,0x32			; 2
0000024e	D4000007		bsr		putCharToANSIScreen
0000024f	D4FFFFCA		bsr		putCharToUART
00000250	4280004A		lix		r8,0x4A			; J
00000251	D4000004		bsr		putCharToANSIScreen
00000252	D4FFFFC7		bsr		putCharToUART
00000253	A1804000		pull	r8
00000254	A1704000		pull	PC				; rts

;
; putCharToANSIScreen - Put a character to the screen
; Character to put to screen is in r8
;

putCharToANSIScreen:
00000255	A0409000		push	r9
00000256	A0405000		push	PAR
00000257	A040A000		push	r10
00000258	42A00002		lix		r10,0x2		; TxReady bit
00000259	42500000		lix		PAR,0x0		; UART Status
waitScreenTxStat:
0000025a	84905000		lpl		r9			; Read Status into r9
0000025b	2399A000		and 	r9,r9,r10
0000025c	C3FFFFFE		bez 	waitScreenTxStat
0000025d	42500001		lix 	PAR,0x1
0000025e	85508000		spl		r8			; echo the character
0000025f	A1A04000		pull	r10
00000260	A1504000		pull	PAR
00000261	A1904000		pull	r9
00000262	A1704000		pull	PC
	
;
; makeBuzz - Make the buzzer buzz
;

makeBuzz:
00000263	A0408000		push	r8
00000264	42800000		lix		r8,0			; first note is 0
00000265	D4000007		bsr 	setNote
00000266	D400000D		bsr		enableBuzzer
00000267	428000FA		lix		r8,250			; count for 1 Sec
00000268	D4000023		bsr		delay_mS		; call delay_ms
00000269	D4000016		bsr		disableBuzzer
0000026a	A1804000		pull	r8
0000026b	A1704000		pull	PC

;
; setNote - Set the note
; pass note in r8
;

setNote:
0000026c	A0408000		push	r8
0000026d	A0405000		push	PAR
0000026e	42504000		lix		PAR,0x4000
0000026f	85508000		spl		r8
00000270	A1504000		pull	PAR
00000271	A1804000		pull	r8
00000272	A1704000		pull	PC

;
; enableBuzzer
;

enableBuzzer:
00000273	A0409000		push	r9
00000274	A0408000		push	r8
00000275	A0405000		push	PAR
00000276	42900010		lix		r9,0x0010		; Buzzer Enable line
00000277	42502800		lix		PAR,0x2800
00000278	84805000		lpl		r8
00000279	22889000		or		r8,r8,r9
0000027a	85508000		spl		r8
0000027b	A1504000		pull	PAR
0000027c	A1804000		pull	r8
0000027d	A1904000		pull	r9
0000027e	A1704000		pull	PC

;
; disableBuzzer
;

disableBuzzer:
0000027f	A0409000		push	r9
00000280	A0408000		push	r8
00000281	A0405000		push	PAR
00000282	4290FFEF		lix		r9,0xffef		; Buzzer Disable line
00000283	42502800		lix		PAR,0x2800
00000284	84805000		lpl		r8
00000285	23889000		and		r8,r8,r9
00000286	85508000		spl		r8
00000287	A1504000		pull	PAR
00000288	A1804000		pull	r8
00000289	A1904000		pull	r9
0000028a	A1704000		pull	PC
	
; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
0000028b	A0409000		push	r9
0000028c	42503802		lix		PAR,0x3802		; address of the mSec counter
0000028d	84905000		lpl		r9				; read the peripheral counter into r9
0000028e	20898000		add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
0000028f	84905000		lpl		r9				; check the elapsed time counter
00000290	30389000		cmp		r8,r9
00000291	CCFFFFFE		blt		loop_delay_mS
00000292	A1904000		pull	r9
00000293	A1704000		pull	PC

;
; getPS2Char
; returns character received in r8
;

getPS2Char:
00000294	A0409000		push	r9
00000295	A0405000		push	PAR
00000296	42501000		lix	PAR,0x1000	; PS/2 Status
waitPS2RxStat:
00000297	84905000		lpl	r9			; Read Status into r9
00000298	23991000		and r9,r9,r1
00000299	C3FFFFFE		bez waitPS2RxStat
getCharFromPS2:
0000029a	42500800		lix PAR,0x0800
0000029b	84805000		lpl	r8
0000029c	42501000		lix	PAR,0x1000	; PS/2 Status
whilePS2RxStat:
0000029d	A1504000		pull	PAR
0000029e	A1904000		pull	r9
0000029f	A1704000		pull	PC

