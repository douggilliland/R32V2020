;
; G001-Hex_Guess_ESP - Guess a number
; Number hex 0x00-0xff
;

banner:			.string "G001-Hex_Guess_ESP"
keyToStart:		.string "Hit any key to start"
guessString:	.string "Guess a hex number (0x00-0xFF) : "
; lineBuff is 80 characters long
lineBuff:		.string "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
syntaxError:	.string "*** Bad number error (at a2h_Error) ***"
tooHigh:		.string "Your guess was too high"
tooLow:			.string "Your guess was too low"
gotItRight:		.string "Congratulations, you got it right"
numberOfGuesses: .string "Number of Guesses : "

;
; Read a line from the UART and parse the line
; r14 = number of tries
; r15 = random number
;

main:
00000000	D400018E	bsr		clearScreen_ANSI_UART	; clear both screens
00000001	D4000186	bsr		newLine_ANSI_UART		; UART does not start at the top of the screen
00000002	42800000	lix		r8,banner.lower			; print program banner
00000003	D400016D	bsr		printString_ANSI_UART
00000004	D4000183	bsr		newLine_ANSI_UART		; start 2 lines down
00000005	D4000182	bsr		newLine_ANSI_UART
00000006	42800014	lix		r8,keyToStart.lower		; wait for keypress to ensure random number
00000007	D4000169	bsr		printString_ANSI_UART
00000008	42E00000	lix		r14,0					; number of tries
waitForKeyHit:
00000009	D400013F	bsr		checkForCharAndDiscard	; returns 1 when key was pressed
0000000a	39380000	cmpi	r8,0x00					; wait for keypress
0000000b	D1FFFFFE	beq		waitForKeyHit
0000000c	D400017B	bsr		newLine_ANSI_UART		; extra LF to move down
runAgain:
0000000d	D4000027	bsr		randomNumber_8bits		; pull random number from counter
0000000e	21F80000	addi	r15,r8,0				; r15 has the random number
notRightCode:
0000000f	21EE0001	addi	r14,r14,1				; increment number of tries
00000010	4280002C	lix		r8,guessString.lower
00000011	D400015F	bsr		printString_ANSI_UART
00000012	D4000028	bsr		readToLineBuffer		; read in the line
; count add length check here
00000013	42800050	lix		r8,lineBuff.lower
00000014	D40001A0	bsr		hexToSevenSeg_ANSI_UART			; convert input string to hex pair (single 8 bit value)
00000015	2B8800FF	andi	r8,r8,0xff				; extra mask (probably no longer needed)
00000016	3838F000	cmp		r8,r15					; check if guess is correct
00000017	D100000C	beq		guessedIt				; guessed correctly
00000018	CC000006	blt		tooHighCase				; guess was too high
tooLowCase:
00000019	428000E4	lix		r8,tooLow.lower			; not equal or high means too low
0000001a	D4000156	bsr		printString_ANSI_UART
0000001b	D400016C	bsr		newLine_ANSI_UART
0000001c	D400016B	bsr		newLine_ANSI_UART
0000001d	C0FFFFF2	bra		notRightCode			; try again
tooHighCase:
0000001e	428000CC	lix		r8,tooHigh.lower		; guess was too high
0000001f	D4000151	bsr		printString_ANSI_UART
00000020	D4000167	bsr		newLine_ANSI_UART
00000021	D4000166	bsr		newLine_ANSI_UART
00000022	C0FFFFED	bra		notRightCode			; try again
guessedIt:
00000023	428000FC	lix		r8,gotItRight.lower		; guess was correct
00000024	D400014C	bsr		printString_ANSI_UART
00000025	D4000162	bsr		newLine_ANSI_UART
00000026	42800120	lix		r8,numberOfGuesses.lower ; print number of guesses
00000027	D4000149	bsr		printString_ANSI_UART
00000028	218E0000	addi	r8,r14,0				; printLongANSI_UART needs value in r8
00000029	D40001B8	bsr		printByte_ANSI_UART
0000002a	D400015D	bsr		newLine_ANSI_UART
endStop:
0000002b	D400015C	bsr		newLine_ANSI_UART
0000002c	42800014	lix		r8,keyToStart.lower		; wait for keypress to ensure random number
0000002d	D4000143	bsr		printString_ANSI_UART
0000002e	42E00000	lix		r14,0					; number of tries
waitForKeyHit2:
0000002f	D4000119	bsr		checkForCharAndDiscard	; returns 1 when key was pressed
00000030	39380000	cmpi	r8,0x00					; wait for keypress
00000031	D1FFFFFE	beq		waitForKeyHit2
00000032	D4000155	bsr		newLine_ANSI_UART
00000033	C0FFFFDA	bra		runAgain
;
; randomNumber_8bits - Generate a random number - 8-bit value
; 0x3803 is the Processor instruction counter
; The number relies on the delay in the user hitting the key at a random time
;

randomNumber_8bits:
00000034	A0405000	push	PAR
00000035	42503803	lix		PAR,0x3803
00000036	84805000	lpl		r8
00000037	2B8800FF	andi	r8,r8,0xff
00000038	A1504000	pull	PAR
00000039	A1704000	pull	PC

; common libraries go here at the end so they get assembled in after the application

;--------------------------------------------------------------------
; bufferedIO.asm - collection of buffered I/O routines
;
; readToLineBuffer - Reads the UART and fills a buffer with the characters received
; r8 received character - Character received from the UART
; r9 is the input buffer length
; r10 used to test the backspace doesn't go past the start of the buffer
; DAR points to lineBuff current character position
;

readToLineBuffer:
0000003a	A0408000	push	r8
0000003b	A0409000	push	r9
0000003c	A040A000	push	r10
0000003d	A0406000	push	DAR
0000003e	42600050	lix		DAR,lineBuff.lower	; DAR pointer = start of line buffer
0000003f	4290004F	lix		r9,79				; number of chars in the line buffer
loopReadLine:
00000040	D40000F8	bsr		waitReadPS2_UART	; Get a character from the UART
00000041	D4000158	bsr		write_ANSI_UART		; Echo character back to the UART
00000042	3938000D	cmpi	r8,0x0D				; check if received char was end of line
00000043	D1000006	beq		gotEOL
00000044	3938007F	cmpi	r8,0x7F
00000045	D1000009	beq		gotBackspace
00000046	69608000	sdbp	r8
00000047	20992000	add		r9,r9,MINUS1
00000048	C7FFFFF8	bnz		loopReadLine		; Next char would overflow
; tbd add code for line too long
gotEOL:
00000049	4280000A	lix		r8,0x0A				; Echo line feed after CR
0000004a	D400014F	bsr		write_ANSI_UART	; Put the character to the screen
0000004b	D4000045	bsr		putChar_UART		; Echo character back to the UART
0000004c	61600000	sdb		r0					; null at end of line read
0000004d	C0000007	bra		doneHandlingLine
gotBackspace:
0000004e	20662000	add		DAR,DAR,MINUS1
0000004f	42A00050	lix		r10,lineBuff.lower	; r10 pointer = start of line buffer
00000050	383A6000	cmp		r10,DAR
00000051	CFFFFFEF	bgt		loopReadLine
00000052	216A0000	addi	DAR,r10,0
00000053	C0FFFFED	bra		loopReadLine
doneHandlingLine:
00000054	A1604000	pull	DAR
00000055	A1A04000	pull	r10
00000056	A1904000	pull	r9
00000057	A1804000	pull	r8
00000058	A1704000	pull	PC

;
; printANSICode - Send the ANSI Escape Sequence
; r8 - points to the string
; This routine supplies the ESC
;

printANSICode:
00000059	A0408000	push	r8
0000005a	A0408000	push	r8
0000005b	4280001B	lix		r8,0x1b			; ESC
0000005c	D4000043	bsr		putChar_ANSI
0000005d	A1804000	pull	r8
0000005e	D4000053	bsr		printString_ANSI
0000005f	A1804000	pull	r8
00000060	A1704000	pull	PC

;
; printLong
; r8 contains the long value to print
;

printLong:
00000061	A0408000	push	r8
00000062	A0409000	push	r9
00000063	A040A000	push	r10
00000064	A0408000	push	r8				; temporarily save r8
00000065	42800030	lix		r8,0x30
00000066	D4000133	bsr		write_ANSI_UART
00000067	42800078	lix		r8,0x78
00000068	D4000131	bsr		write_ANSI_UART
00000069	A1804000	pull	r8				; restore r8
0000006a	42900008	lix		r9,8			; loop counter
doNextPrintLong:
0000006b	34808000	rol1	r8,r8
0000006c	34808000	rol1	r8,r8
0000006d	34808000	rol1	r8,r8
0000006e	34808000	rol1	r8,r8
0000006f	D4000007	bsr		printHexVal
00000070	23990001	subi	r9,r9,1
00000071	C7FFFFFA	bnz		doNextPrintLong
00000072	A1A04000	pull	r10
00000073	A1904000	pull	r9
00000074	A1804000	pull	r8
00000075	A1704000	pull	PC

;
; printHexVal
;

printHexVal:
00000076	A0408000	push	r8
00000077	2B88000F	andi	r8,r8,0xf
00000078	39380009	cmpi	r8,9
00000079	CC000004	blt		printHexLetter
0000007a	21880030	addi	r8,r8,0x30
0000007b	D400011E	bsr		write_ANSI_UART
0000007c	C0000003	bra		donePrintHexVal
printHexLetter:
0000007d	21880037	addi	r8,r8,0x37		; 'A' - 10
0000007e	D400011B	bsr		write_ANSI_UART
donePrintHexVal:
0000007f	A1804000	pull	r8
00000080	A1704000	pull	PC

;--------------------------------------------------------------------
; switches.asm

;
; readSws
; switches value returned in r8
; switches are high when pressed
; Switches d0-d2 are the pushbutton switches (inverted in FPGA hardware)
; 	Pushbutton switches are debounced
; Switches d3-10 are the DIP switches (not inverted)
;

readSws:
00000081	A0405000	push	PAR
00000082	42502000	lix		PAR,0x2000	; Switches address
00000083	84805000	lpl		r8			; Read switches into r9
00000084	2B880FFF	andi	r8,r8,0xfff	; just the switches
00000085	A1504000	pull	PAR
00000086	A1704000	pull	PC

;--------------------------------------------------------------------
; uart.asm

missingHandshake:	.string "Missing handshake"

;
; waitGetCharFromUART
; returns character received in r8
; function is blocking until a character is received from the UART
;

waitGetCharFromUART:
00000087	A0405000	push	PAR
00000088	42501800	lix		PAR,0x1800	; UART Status
waitUartRxStat:
00000089	84805000	lpl		r8			; Read Status into r8
0000008a	2B880001	andi 	r8,r8,0x1
0000008b	C3FFFFFE	bez 	waitUartRxStat
0000008c	42501801	lix 	PAR,0x1801
0000008d	84805000	lpl		r8
0000008e	A1504000	pull	PAR
0000008f	A1704000	pull	PC

;
; putChar_UART - Put a character to the UART
; passed character in r8 is sent out the UART
;

putChar_UART:
00000090	A0405000	push	PAR
00000091	A0408000	push	r8
00000092	42501800	lix		PAR,0x1800	; UART Status
waitUartTxStat:
00000093	84805000	lpl		r8			; Read Status into r8
00000094	2B880002	andi 	r8,r8,0x2
00000095	C7000005	bnz 	uartRdy
; Remind user to enable HW handshake
; would be better to add a HW handshake timeout
; Since the USB is so much faster it is unlikely this path
;	will be exercised.
; For cards with RS-232 serial this would be a serious concern
; It's more likely that PuTTY needed to be run in HW handshake mode.
handshakeStuck:
00000096	42800138	lix		r8,missingHandshake.lower
00000097	D400001A	bsr		printString_ANSI
00000098	A1804000	pull	r8
00000099	C0000004	bra		getOut
uartRdy:
0000009a	42501801	lix 	PAR,0x1801
0000009b	A1804000	pull	r8
0000009c	85508000	spl		r8			; echo the character
getOut:
0000009d	A1504000	pull	PAR
0000009e	A1704000	pull	PC

;--------------------------------------------------------------------
; ANSIScreen.asm

;
; putChar_ANSI - Put a character to the screen
; Character to put to screen is in r8
;

putChar_ANSI:
0000009f	A0409000	push	r9
000000a0	A0405000	push	PAR
000000a1	42500000	lix		PAR,0x0		; UART Status
waitScreenTxStat:
000000a2	84905000	lpl		r9			; Read Status into r9
000000a3	2B990002	andi	r9,r9,0x2
000000a4	C3FFFFFE	bez 	waitScreenTxStat
000000a5	42500001	lix 	PAR,0x1
000000a6	85508000	spl		r8			; echo the character
000000a7	A1504000	pull	PAR
000000a8	A1904000	pull	r9
000000a9	A1704000	pull	PC

;
; newLine_ANSI - Print out a newLine_ANSI (CR-LF)
;

newLine_ANSI:
000000aa	A0408000	push	r8
000000ab	4280000A	lix		r8,0x0A				; Line Feed
000000ac	D4FFFFF3	bsr		putChar_ANSI	; Put the character to the screen
000000ad	4280000D	lix		r8,0x0D				; Carriage Return
000000ae	D4FFFFF1	bsr		putChar_ANSI	; Echo character back to the UART
000000af	A1804000	pull	r8
000000b0	A1704000	pull	PC

;
; printString_ANSI - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI:
000000b1	A0408000	push	r8					; save r8
000000b2	A0406000	push	DAR
000000b3	20680000	add		DAR,r8,ZERO			; set the start of the string
nextCharANSI:
000000b4	68806000	ldbp	r8					; get the character01
000000b5	39380000	cmpi	r8,0x0				; Null terminated string
000000b6	D1000003	beq		donePrANSIStr		; done if null
000000b7	D4FFFFE8	bsr		putChar_ANSI	; write out the character
000000b8	C0FFFFFC	bra		nextCharANSI
donePrANSIStr:
000000b9	A1604000	pull	DAR					; restore DAR
000000ba	A1804000	pull	r8					; restore r8
000000bb	A1704000	pull	PC					; rts

;
; printByte_ANSI
; r8 contains the char value to print
;

printByte_ANSI:
000000bc	A0408000	push	r8
000000bd	A0409000	push	r9
000000be	A0408000	push	r8				; temporarily save r8
000000bf	A1804000	pull	r8				; restore r8
000000c0	42900002	lix		r9,2			; loop counter
000000c1	31808000	sl8		r8,r8
000000c2	31808000	sl8		r8,r8
000000c3	31808000	sl8		r8,r8
doNextprintByte_ANSI:
000000c4	34808000	rol1	r8,r8
000000c5	34808000	rol1	r8,r8
000000c6	34808000	rol1	r8,r8
000000c7	34808000	rol1	r8,r8
000000c8	D4000006	bsr		printHexVal_ANSI
000000c9	23990001	subi	r9,r9,1
000000ca	C7FFFFFA	bnz		doNextprintByte_ANSI
000000cb	A1904000	pull	r9
000000cc	A1804000	pull	r8
000000cd	A1704000	pull	PC

;
; printHexValANSI
;

printHexVal_ANSI:
000000ce	A0408000	push	r8
000000cf	2B88000F	andi	r8,r8,0xf
000000d0	39380009	cmpi	r8,9
000000d1	CC000004	blt		printHexLetterANSI
000000d2	21880030	addi	r8,r8,0x30
000000d3	D4FFFFCC	bsr		putChar_ANSI
000000d4	C0000003	bra		donePrintHexValANSI
printHexLetterANSI:
000000d5	21880037	addi	r8,r8,0x37		; 'A' - 10
000000d6	D4FFFFC9	bsr		putChar_ANSI
donePrintHexValANSI:
000000d7	A1804000	pull	r8
000000d8	A1704000	pull	PC

;
; clearScreen_ANSI - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
; No passed value
; Uses r8 (saved during function)
; no return value
;

clearScreen_ANSI:
000000d9	A0408000	push	r8				; save r8
000000da	4280001B	lix		r8,0x1b			; ESC
000000db	D4FFFFC4	bsr		putChar_ANSI
000000dc	4280005B	lix		r8,0x5b			; [
000000dd	D4FFFFC2	bsr		putChar_ANSI
000000de	42800032	lix		r8,0x32			; 2
000000df	D4FFFFC0	bsr		putChar_ANSI
000000e0	4280004A	lix		r8,0x4A			; J
000000e1	D4FFFFBE	bsr		putChar_ANSI
000000e2	A1804000	pull	r8
000000e3	A1704000	pull	PC				; rts

;
; printLong_ANSI
; r8 contains the long value to print
;

printLong_ANSI:
000000e4	A0408000	push	r8
000000e5	A0409000	push	r9
000000e6	A0408000	push	r8				; temporarily save r8
000000e7	42800030	lix		r8,0x30			; print 0x
000000e8	D4FFFFB7	bsr		putChar_ANSI
000000e9	42800078	lix		r8,0x78
000000ea	D4FFFFB5	bsr		putChar_ANSI
000000eb	A1804000	pull	r8				; restore r8
000000ec	42900008	lix		r9,8			; loop counter
doNextprintLong_ANSI:
000000ed	34808000	rol1	r8,r8
000000ee	34808000	rol1	r8,r8
000000ef	34808000	rol1	r8,r8
000000f0	34808000	rol1	r8,r8
000000f1	D4FFFFDD	bsr		printHexVal_ANSI
000000f2	23990001	subi	r9,r9,1
000000f3	C7FFFFFA	bnz		doNextprintLong_ANSI
000000f4	A1904000	pull	r9
000000f5	A1804000	pull	r8
000000f6	A1704000	pull	PC
;--------------------------------------------------------------------
; buzzer.asm

;
; makeBuzz - Make the buzzer buzz
;

makeBuzz:
000000f7	A0408000	push	r8
000000f8	42800000	lix		r8,0			; first note is 0
000000f9	D400001A	bsr 	setNote
000000fa	D4000006	bsr		enableBuzzer
000000fb	428000FA	lix		r8,250			; count for 1 Sec
000000fc	D400001C	bsr		delay_mS		; call delay_ms
000000fd	D400000C	bsr		disableBuzzer
000000fe	A1804000	pull	r8
000000ff	A1704000	pull	PC
;
; enableBuzzer
;

enableBuzzer:
00000100	A0408000	push	r8
00000101	A0405000	push	PAR
00000102	42502800	lix		PAR,0x2800
00000103	84805000	lpl		r8
00000104	29880010	ori		r8,r8,0x10
00000105	85508000	spl		r8
00000106	A1504000	pull	PAR
00000107	A1804000	pull	r8
00000108	A1704000	pull	PC

;
; disableBuzzer
;

disableBuzzer:
00000109	A0408000	push	r8
0000010a	A0405000	push	PAR
0000010b	4290FFEF	lix		r9,0xffef		; Buzzer Disable line
0000010c	42502800	lix		PAR,0x2800
0000010d	84805000	lpl		r8
0000010e	2B88FFEF	andi	r8,r8,0xffef
0000010f	85508000	spl		r8
00000110	A1504000	pull	PAR
00000111	A1804000	pull	r8
00000112	A1704000	pull	PC

;--------------------------------------------------------------------
; music.asm

;
; setNote - Set the note
; pass note in r8
; returns note
;

setNote:
00000113	A0405000	push	PAR
00000114	42504000	lix		PAR,0x4000
00000115	85508000	spl		r8
00000116	A1504000	pull	PAR
00000117	A1704000	pull	PC
;--------------------------------------------------------------------
; timers.asm

; delay_mS - delay for the number of mSecs passed in r8
; pass mSec delay in r8
; Routine uses r9

delay_mS:
00000118	A0409000	push	r9
00000119	42503802	lix		PAR,0x3802		; address of the mSec counter
0000011a	84905000	lpl		r9				; read the peripheral counter into r9
0000011b	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_mS:
0000011c	84905000	lpl		r9				; check the elapsed time counter
0000011d	38389000	cmp		r8,r9
0000011e	CCFFFFFE	blt		loop_delay_mS
0000011f	A1904000	pull	r9
00000120	A1704000	pull	PC

;
; delay_uS - delay for the number of uSecs
; pass mSec delay in r8
; Uses routine uses r9 (saved and restored)
;

delay_uS:
00000121	A0409000	push	r9
00000122	A0405000	push	PAR
00000123	42503801	lix		PAR,0x3801		; address of the uSec counter
00000124	84905000	lpl		r9				; read the peripheral counter into r9
00000125	20898000	add		r8,r9,r8		; terminal counter to wait until is in r8
loop_delay_uS:
00000126	84905000	lpl		r9				; check the elapsed time counter
00000127	38389000	cmp		r8,r9
00000128	CCFFFFFE	blt		loop_delay_uS
00000129	A1504000	pull	PAR
0000012a	A1904000	pull	r9
0000012b	A1704000	pull	PC

;--------------------------------------------------------------------
; ps2.asm - Functions to read the PS/2 keyboard
;
; Address	Function
; x0800 	Latched Keyboard Data
; x0801 	Latched Keyboard Status
; x0802 	Polled Keyboard Data
; x0803 	Polled Keyboard Status
;
; getChar_PS2
; returns character received in r8
;

getChar_PS2:
0000012c	A0409000	push	r9
0000012d	A0405000	push	PAR
0000012e	42500801	lix		PAR,0x0801	; PS/2 Status
waitPS2RxStat:
0000012f	84905000	lpl		r9			; Read Status into r9
00000130	2B990001	andi	r9,r9,0x1
00000131	C3FFFFFE	bez 	waitPS2RxStat
getCharFromPS2:
00000132	42500800	lix 	PAR,0x0800
00000133	84805000	lpl		r8
00000134	42500801	lix		PAR,0x0801	; PS/2 Status
whilePS2RxStat:
00000135	A1504000	pull	PAR
00000136	A1904000	pull	r9
00000137	A1704000	pull	PC

; waitReadPS2_UART
; wait for character from either
;	the PS/2 keyboard or the UART serial
; r8 = read character

waitReadPS2_UART:
00000138	A0405000	push	PAR
checkCharFromPS2:
00000139	42500801	lix		PAR,0x0801	; PS/2 Status
0000013a	84805000	lpl		r8			; Read Status
0000013b	2B880001	andi	r8,r8,0x1	; =1 when char received
0000013c	C3000004	bez 	checkUARTStat
0000013d	42500800	lix 	PAR,0x0800	; PS/2 Data
0000013e	84805000	lpl		r8
0000013f	C0000007	bra		gotPS2Char
checkUARTStat:
00000140	42501800	lix		PAR,0x1800	; UART Status
00000141	84805000	lpl		r8			; Read Status
00000142	2B880001	andi 	r8,r8,0x1	; =1 when char received
00000143	C3FFFFF6	bez 	checkCharFromPS2
00000144	42501801	lix 	PAR,0x1801	; UART Data
00000145	84805000	lpl		r8
gotPS2Char:
00000146	A1504000	pull	PAR
00000147	A1704000	pull	PC

; checkForCharAndDiscard - Check for a character in UART or PS/2
; Discard the character received
; return whether char was present (1) or no char was present (0)

checkForCharAndDiscard:
00000148	A0405000	push	PAR
00000149	42500801	lix		PAR,0x0801	; PS/2 Status
0000014a	84805000	lpl		r8			; Read Status
0000014b	2B880001	andi	r8,r8,0x1	; =1 when char received
0000014c	C3000005	bez 	checkUARTStat2
0000014d	42500800	lix 	PAR,0x0800	; PS/2 Data
0000014e	84805000	lpl		r8			; throw away char
0000014f	42800001	lix		r8,0x1
00000150	C000000A	bra		gotChar
checkUARTStat2:
00000151	42501800	lix		PAR,0x1800	; UART Status
00000152	84805000	lpl		r8			; Read Status
00000153	2B880001	andi 	r8,r8,0x1	; =1 when char received
00000154	C3000005	bez 	noCharReceived
00000155	42501801	lix 	PAR,0x1801	; UART Data
00000156	84805000	lpl		r8
00000157	42800001	lix		r8,1
00000158	C0000002	bra		gotChar
noCharReceived:
00000159	42800000	lix		r8,0
gotChar:
0000015a	A1504000	pull	PAR
0000015b	A1704000	pull	PC

;
; waitCharPolled_PS2 - Check the polled character interface
; wait for a character
; return when a character is present
; returns character received in r8
;

waitCharPolled_PS2:
0000015c	A0405000	push	PAR
0000015d	42500803	lix		PAR,0x0803	; PS/2 Status
waitPS2RxStatPolled:
0000015e	84805000	lpl		r8			; Read Status into r8
0000015f	2B880001	andi 	r8,r8,0x1
00000160	C3FFFFFE	bez 	waitPS2RxStatPolled
getCharFromPS2Polled:
00000161	42500802	lix 	PAR,0x0802
00000162	84805000	lpl		r8
whilePS2RxStatPolled:
00000163	A1504000	pull	PAR
00000164	A1704000	pull	PC

;
; checkGetStat_PS2 - Checks the polling status
; Polled interface is active while the keyboard key is pressed
; returns
;	-1 if there is no character,
;	character if there is a character
;

checkGetStat_PS2:
00000165	A0405000	push	PAR
00000166	42500803	lix		PAR,0x0803	; PS/2 Status
00000167	84805000	lpl		r8			; Read Status into r8
00000168	2B880001	andi	r8,r8,0x1
00000169	C3000004	bez		charNotPresent
0000016a	42500802	lix		PAR,0x0802
0000016b	84805000	lpl		r8
0000016c	C0000002	bra		gotCharIn
charNotPresent:
0000016d	20802000	add		r8,ZERO,MINUS1
gotCharIn:
0000016e	A1504000	pull	PAR
0000016f	A1704000	pull	PC
;--------------------------------------------------------------------
; ANSI_UART_io.asm

;
; ANSI_UART_io.asm -
;

;
; printString_ANSI_UART - Print a screen to the current screen position
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printString_ANSI_UART:
00000170	A0408000	push	r8					; save r8
00000171	A0406000	push	DAR
00000172	20680000	add		DAR,r8,ZERO			; set the start of the string
nextChar:
00000173	68806000	ldbp	r8					; get the character01
00000174	39380000	cmpi	r8,0x0				; Null terminated string
00000175	D1000003	beq		donePrStr			; done if null
00000176	D4000023	bsr		write_ANSI_UART	; write out the character
00000177	C0FFFFFC	bra		nextChar
donePrStr:
00000178	A1604000	pull	DAR					; restore DAR
00000179	A1804000	pull	r8					; restore r8
0000017a	A1704000	pull	PC					; rts

;
; printLinebuffer_ANSI_UART - Print a screen to the current screen position with CRLF at the end
; pass value : r8 points to the start of the string in Data memory
; strings are bytes packed into long words
; strings are null terminated
;

printLinebuffer_ANSI_UART:
0000017b	A0408000	push	r8					; save r8
0000017c	A0406000	push	DAR
0000017d	21680000	addi	DAR,r8,0x0			; set the start of the string
nextChar2:
0000017e	68806000	ldbp	r8					; get the character
0000017f	39380000	cmpi	r8,0x0				; Null terminated string
00000180	D1000003	beq		donePrStr2			; done if null
00000181	D4000018	bsr		write_ANSI_UART	; write out the character
00000182	C0FFFFFC	bra		nextChar2
donePrStr2:
00000183	D4000004	bsr		newLine_ANSI_UART
00000184	A1604000	pull	DAR					; restore DAR
00000185	A1804000	pull	r8					; restore r8
00000186	A1704000	pull	PC					; rts

;
; newLine_ANSI_UART - Print out a newLine_ANSI_UART (CR-LF)
;

newLine_ANSI_UART:
00000187	A0408000	push	r8
00000188	4280000A	lix		r8,0x0A				; Line Feed
00000189	D4000010	bsr		write_ANSI_UART	; Put the character to the screen
0000018a	4280000D	lix		r8,0x0D				; Carriage Return
0000018b	D400000E	bsr		write_ANSI_UART		; Echo character back to the UART
0000018c	A1804000	pull	r8
0000018d	A1704000	pull	PC

;
; clearScreen_ANSI_UART - Clear the screen routine
; ANSI Terminal has an escape sequence which clears the screen and homes cursor
;

clearScreen_ANSI_UART:
0000018e	A0408000	push	r8				; save r8
0000018f	4280001B	lix		r8,0x1b			; ESC
00000190	D4000009	bsr		write_ANSI_UART
00000191	4280005B	lix		r8,0x5b			; [
00000192	D4000007	bsr		write_ANSI_UART
00000193	42800032	lix		r8,0x32			; 2
00000194	D4000005	bsr		write_ANSI_UART
00000195	4280004A	lix		r8,0x4A			; J
00000196	D4000003	bsr		write_ANSI_UART
00000197	A1804000	pull	r8
00000198	A1704000	pull	PC				; rts

; write_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

write_ANSI_UART:
00000199	D4FFFF06	bsr		putChar_ANSI
0000019a	D4FFFEF6	bsr		putChar_UART
0000019b	A1704000	pull	PC

;
; asciiToHex_ANSI_UART - Convert a single ASCII hex character into a nibble
; Make conversion case insensitive
; Character to convert is passed in r8
;	'0' = 0x30
;	'9' = 0x39
;	'A' = 0x41
;	'F' = 0x46
;	'a' = 0x61
;	'f' = 0x66
; Result is returned in r8
;	0x0-0xf - Legal Values
;	'DEAD' - Not hex character
;

asciiToHex_ANSI_UART:
0000019c	39380066	cmpi	r8,0x66			; past 'f'
0000019d	CC000011	blt		a2h_Error
0000019e	39380030	cmpi	r8,0x30			; below '0'
0000019f	CF00000F	bgt		a2h_Error
000001a0	3938003A	cmpi	r8,0x3A			; '0' - '9'
000001a1	CF000009	bgt		gotDigit
000001a2	39380041	cmpi	r8,0x41			; ':' - '@'
000001a3	CF00000B	bgt		a2h_Error
000001a4	39380047	cmpi	r8,0x47			; 'A' - 'F'
000001a5	CC000007	blt		gotUpperLetter
000001a6	39380061	cmpi	r8,0x61			; 'G' - 'tick'
000001a7	CC000007	blt		a2h_Error
; Lower case letter
000001a8	23880057	subi	r8,r8,0x57
000001a9	C000000A	bra		doneConvA2H
; number 0-9
gotDigit:
000001aa	23880030	subi	r8,r8,0x30
000001ab	C0000008	bra		doneConvA2H
; A-F
gotUpperLetter:
000001ac	23880037	subi	r8,r8,0x37
000001ad	C0000006	bra		doneConvA2H
a2h_Error:
000001ae	428000A4	lix		r8,syntaxError.lower
000001af	D4FFFFD8	bsr		newLine_ANSI_UART
000001b0	D4FFFFC0	bsr		printString_ANSI_UART
000001b1	D4FFFFD6	bsr		newLine_ANSI_UART
000001b2	4280DEAD	lix		r8,0xDEAD
doneConvA2H:
000001b3	A1704000	pull	PC

; hexToSevenSeg_ANSI_UART - Convert a two ASCII digit value into a hex byte
; Passed: r8 points to the start of the hex string
; Returned: r8 contains the hex value of the string
; Put the byte to the Seven Segment Display
;

hexToSevenSeg_ANSI_UART:
000001b4	A0409000	push	r9
000001b5	A0406000	push	DAR
000001b6	A0405000	push	PAR
000001b7	42900000	lix		r9,0
000001b8	20680000	add		DAR,r8,ZERO		; Address of lineBuff (passed into this routine)
000001b9	68806000	ldbp	r8
000001ba	D4FFFFE2	bsr		asciiToHex_ANSI_UART
000001bb	3938DEAD	cmpi	r8,0xDEAD
000001bc	D1000011	beq		badHexVal
000001bd	2B88000F	andi	r8,r8,0xf
000001be	28998000	or		r9,r9,r8
000001bf	30909000	sl1		r9,r9
000001c0	30909000	sl1		r9,r9
000001c1	30909000	sl1		r9,r9
000001c2	30909000	sl1		r9,r9
000001c3	60806000	ldb		r8
000001c4	D4FFFFD8	bsr		asciiToHex_ANSI_UART
000001c5	3938DEAD	cmpi	r8,0xDEAD
000001c6	D1000007	beq		badHexVal
000001c7	2B88000F	andi	r8,r8,0xf
000001c8	28998000	or		r9,r9,r8
000001c9	42503000	lix		PAR,0x3000		; seven segment display
000001ca	85509000	spl		r9
000001cb	20890000	add		r8,r9,ZERO
000001cc	C0000006	bra		valOKDone
badHexVal:
000001cd	428000A4	lix		r8,syntaxError.lower
000001ce	D4FFFFB9	bsr		newLine_ANSI_UART
000001cf	D4FFFFA1	bsr		printString_ANSI_UART
000001d0	D4FFFFB7	bsr		newLine_ANSI_UART
000001d1	4280DEAD	lix		r8,0xDEAD
valOKDone:
000001d2	A1504000	pull	PAR
000001d3	A1604000	pull	DAR
000001d4	A1904000	pull	r9
000001d5	A1704000	pull	PC

;
; printHexVal_ANSI_UART
;

printHexVal_ANSI_UART:
000001d6	A0408000	push	r8
000001d7	2B88000F	andi	r8,r8,0xf
000001d8	39380009	cmpi	r8,9
000001d9	CC000004	blt		printHexLetterANSI_UART
000001da	21880030	addi	r8,r8,0x30
000001db	D4FFFFBE	bsr		write_ANSI_UART
000001dc	C0000003	bra		doneprintHexValANSI_UART
printHexLetterANSI_UART:
000001dd	21880037	addi	r8,r8,0x37		; 'A' - 10
000001de	D4FFFFBB	bsr		write_ANSI_UART
doneprintHexValANSI_UART:
000001df	A1804000	pull	r8
000001e0	A1704000	pull	PC

;
; printByte_ANSI_UART
; r8 contains the short value to print
;

printByte_ANSI_UART:
000001e1	A0408000	push	r8
000001e2	A0409000	push	r9
000001e3	A0408000	push	r8				; temporarily save r8
000001e4	42800030	lix		r8,0x30			; print 0x
000001e5	D400003E	bsr		putChar_ANSI_UART
000001e6	42800078	lix		r8,0x78
000001e7	D400003C	bsr		putChar_ANSI_UART
000001e8	A1804000	pull	r8				; restore r8
000001e9	42900002	lix		r9,2			; loop counter
000001ea	31808000	sl8		r8,r8
000001eb	31808000	sl8		r8,r8
000001ec	31808000	sl8		r8,r8
doNextprintByte_ANSI_UART:
000001ed	34808000	rol1	r8,r8
000001ee	34808000	rol1	r8,r8
000001ef	34808000	rol1	r8,r8
000001f0	34808000	rol1	r8,r8
000001f1	D4FFFFE5	bsr		printHexVal_ANSI_UART
000001f2	23990001	subi	r9,r9,1
000001f3	C7FFFFFA	bnz		doNextprintByte_ANSI_UART
000001f4	A1904000	pull	r9
000001f5	A1804000	pull	r8
000001f6	A1704000	pull	PC

;
; printShort_ANSI_UART
; r8 contains the short value to print
;

printShort_ANSI_UART:
000001f7	A0408000	push	r8
000001f8	A0409000	push	r9
000001f9	A040A000	push	r10
000001fa	A0408000	push	r8				; temporarily save r8
000001fb	42800030	lix		r8,0x30
000001fc	D4FFFF9D	bsr		write_ANSI_UART
000001fd	42800078	lix		r8,0x78
000001fe	D4FFFF9B	bsr		write_ANSI_UART
000001ff	A1804000	pull	r8				; restore r8
00000200	42900004	lix		r9,4			; loop counter
00000201	31808000	sl8		r8,r8
00000202	31808000	sl8		r8,r8
doNextprintShortANSI_UART:
00000203	34808000	rol1	r8,r8
00000204	34808000	rol1	r8,r8
00000205	34808000	rol1	r8,r8
00000206	34808000	rol1	r8,r8
00000207	D4FFFFCF	bsr		printHexVal_ANSI_UART
00000208	23990001	subi	r9,r9,1
00000209	C7FFFFFA	bnz		doNextprintShortANSI_UART
0000020a	A1A04000	pull	r10
0000020b	A1904000	pull	r9
0000020c	A1804000	pull	r8
0000020d	A1704000	pull	PC

;
; printLong_ANSI_UART
; r8 contains the long value to print
;

printLong_ANSI_UART:
0000020e	A0408000	push	r8
0000020f	A0409000	push	r9
00000210	A040A000	push	r10
00000211	A0408000	push	r8				; temporarily save r8
00000212	42800030	lix		r8,0x30
00000213	D4FFFF86	bsr		write_ANSI_UART
00000214	42800078	lix		r8,0x78
00000215	D4FFFF84	bsr		write_ANSI_UART
00000216	A1804000	pull	r8				; restore r8
00000217	42900008	lix		r9,8			; loop counter
doNextprintLongANSI_UART:
00000218	34808000	rol1	r8,r8
00000219	34808000	rol1	r8,r8
0000021a	34808000	rol1	r8,r8
0000021b	34808000	rol1	r8,r8
0000021c	D4FFFFBA	bsr		printHexVal_ANSI_UART
0000021d	23990001	subi	r9,r9,1
0000021e	C7FFFFFA	bnz		doNextprintLongANSI_UART
0000021f	A1A04000	pull	r10
00000220	A1904000	pull	r9
00000221	A1804000	pull	r8
00000222	A1704000	pull	PC

; putChar_ANSI_UART
; write out a character to both
;	the ANSI screen and the UART

putChar_ANSI_UART:
00000223	D4FFFE7C	bsr		putChar_ANSI
00000224	D4FFFE6C	bsr		putChar_UART
00000225	A1704000	pull	PC
